// отже, маємо об’єкт для клонування
let worker = {
  name: 'Modest',
  surname: 'Opakhan',
  age: 42,
  job: {
    speciality: 'frontend',
    skils: ['HTML5', 'CSS3', 'JavaScript', 'React', 'PostreSQL', 'NodeJS'],
    'in Orange team': true,
  },
  'company friends': null,
  statuses: {
    inWork: {
      isAdmin: false,
      isBuisinessAnalitic: false,
      isDeveloper: true,
      isDesigner: false,
      isQA: false,
      passID: 452744879924484,
      annualWage: 120_000,
    },
    inLife: {
      isMaried: false,
      isSingle: false,
      isDivorse: true,
      children: {
        sons: [
          {name: 'Tarry', birthday: '01/09/2000'},
        ],
        daughters: [
          {name: 'Ellis', birthday: '14/07/2017'},
          {name: 'Caroll', birthday: '04/06/2023'}
        ],
      },
      hobbies: ['oil painting', 'arrow hunting'],
    }
  }
};

/* Памятаємо, дублювання змінної об’єкта створює ще одне посилання на той самий об’єкт:
let a = {}; let b = a; тут копіювання посилання і тому a == b ---> true, бо обидві
змінні посилаються на один і той самий об'єкт. Тобто тут об’єкти не є незалежними і зміна
в одному призведе до зміни в іншому.
Якщо нам потрібно дублювати об'єкт і щоб ці обєкти були незалежними копіями, ми можемо 
створити новий об’єкт і повторити структуру існуючого, перебираючи його властивості та 
копіюючи їх на початковому рівні, або
ми можемо використовувати Object.assign(dest, ...sources) для виконання простого клонування 
об’єкта. Але якщо ми маємо у властивостях обєкта інші обєкти, то ми повинні
використовувати таке клонування, яке перевіряє кожне значення властивості obj[key] і, 
якщо це об’єкт, то також копіювати його структуру. Це називається «глибоке клонування» 
або "структуроване клонування". 
Існує метод "structuredClone(object)", який реалізує таке глибоке клонування. Метод 
structuredClone може клонувати більшість типів даних, таких як об’єкти, масиви, примітивні 
значення. Він також підтримує циклічні посилання, коли властивість об’єкта посилається на 
сам об’єкт (безпосередньо або через ланцюжок чи посилання).
Але коли об’єкт, що має бути скопійований, має одну із своїх властивостей функцію, глибоке
копіювання не виконається.
Подібний метод для клонування може бути коли використаєм для цього методи JSON: метод 
конвертації (або серіалізації) в рядок JSON.stringify(obj) та метод конвертування з рядка 
назад в об'єкт JSON.parse(). Щоб створити клон об'єкта потрібно спочатку структуру даних 
серіалізуем в рядок, а потім рядок десеріалізуем в структуру даних. Цей метод також має
обмеження коли в клонрованому об’єкті є функція однією з властивостей. 

Тому потрібно у цих випадках шукати комбінацію методів клонування, написати спеціальний 
код або, щоб "не винаходити колесо", взяти існуючу реалізацію, наприклад _.cloneDeep(obj)
з бібліотеки JavaScript lodash.

Так як наш обєкт не має функції у своїх властивостях то давайте спробуємо тих два метода:*/

// usage:
// let clonedWorker = structuredClone(worker); // повне глибоке клонування об’єкту worker
let clonedWorker = JSON.parse(JSON.stringify(worker)); // повне глибоке клонування об’єкту worker

console.log( clonedWorker );

document.getElementById("obj-copied").innerText = JSON.stringify(clonedWorker, null, 4);