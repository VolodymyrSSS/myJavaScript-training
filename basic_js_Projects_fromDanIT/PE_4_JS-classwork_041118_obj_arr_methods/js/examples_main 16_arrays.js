// Array
// Массив – разновидность объекта, которая предназначена для хранения пронумерованных значений и предлагает дополнительные
// методы для удобного манипулирования такой коллекцией
// Они обычно используются для хранения упорядоченных коллекций данных, например – списка товаров на странице, студентов в группе и т.п.



// Синтаксис для создания нового массива – квадратные скобки со списком элементов внутри
// let arr = [];                                           // пустой массив
// let fruits = ["Яблоко", "Апельсин", "Слива"];           // массив fruits с тремя элементами




// Элементы нумеруются, начиная с нуля
// Чтобы получить нужный элемент из массива – указывается его номер в квадратных скобках:
// let fruits = ["Яблоко", "Апельсин", "Слива"];
// alert( fruits[0] ); // Яблоко
// alert( fruits[1] ); // Апельсин
// alert( fruits[2] ); // Слива
// Элемент можно всегда заменить: fruits[2] = 'Груша';     // теперь ["Яблоко", "Апельсин", "Груша"]
// Или добавить:                  fruits[3] = 'Лимон';     // теперь ["Яблоко", "Апельсин", "Груша", "Лимон"]

// Общее число элементов, хранимых в массиве, содержится в его свойстве length:
// let fruits = ["Яблоко", "Апельсин", "Груша"];
// alert( fruits.length );                                  // выведет: 3

// Через alert можно вывести и массив целиком. При этом его элементы будут перечислены через запятую:
// let fruits = ["Яблоко", "Апельсин", "Груша"];
// alert( fruits );                                        // выведет: Яблоко,Апельсин,Груша

// В массиве может храниться любое число элементов любого типа. В том числе, строки, числа, объекты, вот например:
// let arr = [ 1, 'Имя', { name: 'Петя', surname: 'Сидоров', age: 25 }, true ];
// alert( arr[2].surname );                                // выведет: Сидоров - получаем объект из массива и тут же - его свойство



// специальные методы для массивов
// Одно из применений массива – это очередь. В классическом программировании так называют упорядоченную коллекцию элементов, такую 
// что элементы добавляются в конец, а обрабатываются – с начала. Например, очередь сообщений, которые надо показать на экране
// Eще одна структура данных: стек. Это такая коллекция элементов, в которой новые элементы добавляются в конец и берутся с конца

// pop
// pop - Удаляет последний элемент из массива и возвращает его:
// let fruits = ["Яблоко", "Апельсин", "Груша"];          // массив fruits с 3я элементами
// alert( fruits.pop() );                                 // выведет: Груша - последний удаленный элемент
// alert( fruits );                                       // выведет: Яблоко, Апельсин - теперь масив из 2х элементов

// push
// push - Добавляет элемент в конец массива:
// let fruits = ["Яблоко", "Апельсин"];                  // массив fruits с 2я элементами
// fruits.push("Груша");                                 // добавили элемент "Груша" в конец массива
// alert( fruits );                                      // выведет: Яблоко, Апельсин, Груша
// Вызов fruits.push(...) равнозначен fruits[fruits.length] = ....
 
// shift
// shift - Удаляет из массива первый элемент и возвращает его:
// let fruits = ["Яблоко", "Апельсин", "Груша"];       // массив fruits с 3я элементами
// alert( fruits.shift() );                            // выведет: Яблоко - первый удаленный элемент массива
// alert( fruits );                                    // выведет: Апельсин, Груша - теперь масив из 2х элементов

// unshift
// unshift - Добавляет элемент в начало массива:
// let fruits = ["Апельсин", "Груша"];                  // массив fruits с 2я элементами
// fruits.unshift('Слива');                             // добавили элемент "Слива" в начало массива
// alert( fruits );                                     // выведет: Яблоко, Апельсин, Груша

// Методы push и unshift могут добавлять сразу по несколько элементов:
// var fruits = ["Яблоко"];                              // массив fruits с одним элементом
// fruits.push("Апельсин", "Персик");                    // push - добавляет элементы "Апельсин" и "Персик" в конец массива
// fruits.unshift("Ананас", "Лимон");                    // unshift - добавляет элементы "Ананас" и "Лимон" в начало массива
// alert( fruits );                                      // выведет: Ананас, Лимон, Яблоко, Апельсин, Персик - массив с 5ю элементами




// Массив – это объект, где в качестве ключей выбраны цифры, с дополнительными методами и свойством length.

// Так как это объект, то в функцию он передаётся по ссылке:
// function eatwords(arr) {
//   arr.pop();
// }
// let arr = ["нам", "не", "страшен", "серый", "волк"]        // массив arr с 5ю элем.     ["нам", "не", "страшен", "серый", "волк"]
// alert( arr.length );                                       // выведет: 5
// eatwords(arr);                                             // результат работы функции: ["нам", "не", "страшен", "серый"]
// eatwords(arr);                                             // результат работы функции: ["нам", "не", "страшен"]
// alert( arr.length );                                       // выведет: 3 (в функцию массив не скопирован, а передан по ссылке)


// Ещё одно следствие – можно присваивать в массив любые свойства
// let fruits = [];                                           // создать массив
// fruits[99999] = 5;                                         // присвоить свойство с любым номером
// fruits.age = 25;                                           // назначить свойство со строковым именем
// Как правило, нет причин использовать массив как обычный объект, хотя технически это и возможно

// Но массивы для того и придуманы в JavaScript, чтобы удобно работать именно с упорядоченными, нумерованными данными
// Для этого в них существуют специальные методы и свойство length
// Если в массиве есть пропущенные индексы, то при выводе в большинстве браузеров появляются «лишние» запятые, например:
// let a = [];
// a[0] = 0;
// a[5] = 5;
// alert( a ); // 0,,,,,5
// Эти запятые появляются потому, что алгоритм вывода массива идёт от 0 до arr.length и выводит всё через запятую
// Отсутствие значений даёт несколько запятых подряд


// Методы push/pop выполняются быстро, а shift/unshift – медленно
// fruits.shift();                                          // убрать 1 элемент с начала
// Нужно еще и переместить остальные элементы на их новые индексы
// Операция shift должна выполнить целых три действия: Удалить нулевой элемент, Переместить все свойства влево, с 
// индекса 1 на 0, с 2 на 1 и так далее. Обновить свойство length
// Чем больше элементов в массиве, тем дольше их перемещать, это много операций с памятью
// налогично работает unshift: чтобы добавить элемент в начало массива, нужно сначала перенести вправо, 
// в увеличенные индексы, все существующие
// А что же с push/pop?                    fruits.pop(); // убрать 1 элемент с конца
// Им как раз перемещать ничего не надо. Для того, чтобы удалить элемент, метод pop очищает
// ячейку и уменьшает значение length. Перемещать при pop не требуется, так как прочие элементы после этой операции
// остаются на тех же индексах. Аналогично работает push.



// Перебор элементов
// Для перебора элементов обычно используется цикл:
// let arr = ["Яблоко", "Апельсин", "Груша"];
// for (let i = 0; i < arr.length; i++) {
//   alert( arr[i] );                          // выведет поочередно: Яблоко, Апельсин, Груша
// }
// Так как массив является объектом, то возможен и вариант for..in:
// let arr = ["Яблоко", "Апельсин", "Груша"];
// for (let key in arr) {
//   alert( arr[key] );                       // выведет поочередно: Яблоко, Апельсин, Груша
// }
// Недостатки этого способа: Цикл for..in выведет все свойства объекта, а не только цифровые
// Цикл for (var i=0; i<arr.length; i++) в современных браузерах выполняется в 10-100 раз быстре
// Не используйте for..in для массивa !!!



// length
// Особенности работы length - Встроенные методы для работы с массивом автоматически обновляют его длину length
// Длина length – не количество элементов массива, а последний индекс + 1
// Это легко увидеть на следующем примере:
// let arr = [];
// arr[1000] = true;
// alert(arr.length);                          // выведет: 1001

// Eсли у вас элементы массива нумеруются случайно или с большими пропусками, то стоит подумать о том, чтобы использовать
// обычный объект. Массивы предназначены именно для работы с непрерывной упорядоченной коллекцией элементов

// Используем length для укорачивания массива
// Обычно нам не нужно самостоятельно менять length… Но есть один фокус, который можно провернуть
// При уменьшении length массив укорачивается. Причем этот процесс необратимый, т.е. даже если потом вернуть length 
// обратно – значения не восстановятся:
// let arr = [1, 2, 3, 4, 5];
// arr.length = 2;                             // укоротить до 2 элементов
// alert( arr );                               // выведет: 1, 2
// arr.length = 5;                             // попробуем вернуть length обратно, как было
// alert( arr[3] );                            // выведет: undefined - значения не вернулись

// Самый простой способ очистить массив – это arr.length=0



// new Array()
// Существует еще один синтаксис для создания массива:  let arr = new Array("Яблоко", "Груша", "и т.п.");
// Он редко используется, т.к. квадратные скобки [] короче 
// Но есть одна особенность. Обычно new Array(элементы, ...) создаёт массив из данных элементов, но если у него 
// один аргумент - число, new Array(число), то он создает массив без элементов, но с заданной длиной
// let arr = new Array(2, 3);                     // создан массив c элементами 2, 3
// alert( arr[0] );                               // выведет: 2, все ОК
// arr = new Array(2);                            // а создаст ли массив [2] ?
// alert( arr[0] );                               // выведет: undefined - у нас массив без элементов, длины 2

// Что же такое этот «массив без элементов, но с длиной»? Как такое возможно? Оказывается, очень даже возможно и соответствует 
// объекту {length: 2}. Получившийся массив ведёт себя так, как будто его элементы равны undefined. Это может быть неожиданным
// сюрпризом, поэтому обычно используют квадратные скобки.



// Многомерные массивы
// Массивы в JavaScript могут содержать в качестве элементов другие массивы. Это можно использовать для создания многомерных 
// массивов, например матриц:
// let matrix = [
//   [1, 2, 3],
//   [4, 5, 6],
//   [7, 8, 9]
// ];
// alert( matrix[1][1] ); // выведет:5 - центральный элемент

// Числовые массивы, согласно спецификации, являются объектами, в которые добавили ряд свойств, методов и автоматическую длину length





//                                      П Р И К Л А Д И





/* В нас є довільний масив goods. Скільки в ньому елементів ми не знаемо, але можемо дізнатись застосувавши 
вираз goods.length. Напишіть код для отримання останнього елемента масиву goods  */
// Рішення:
// останній елемент масиву має індекс на 1 менше, ніж довжина усього масиву, бо 1 елемент має індекс 0, тобто:
// let goods = [1й елемент з індексом 0, 2й елемент з індексом 1, 3й елемент з індексом 2, ... останній елемент з індексом length - 1];
// отже: let lastItemGoods = goods[goods.length - 1];        // отримали останній елемент масиву





/* В нас є довільний масив goods. Напишіть код щоб додати в кінець цього масиву значення «Комп'ютер»  */
// Рішення: 
// Останній елемент масиву має індекс goods.length - 1. Тоді з цього випливає, що індекс нового останнього елементу буде goods.length
// і ми можемо записати вираз для додавання останнього елементу:         goods[goods.length] = "Компьютер", або використати вираз push
// let addedLastItem =  goods[goods.push("Комп'ютер")];





/* Створіть массив styles з елементами «Джаз», «Блюз». Потім додайте в його кінець значення «Рок-н-Ролл». Далі, замініть передостаннє
значення з кінця на «Класика». Код заміни предостаннього значення повинен працювати для масивів будь-якої довжини. Потім видаліть
перше значення масиву і виведіть його за допомогою alert. І на кінець, додайте на початок значення «Реп» та «Реггі»  */

// Рішення:
// let styles = ["Джаз", "Блюз"];                      // створений масив styles з 2а елементами "Джаз" і "Блюз"
// console.log(styles);                                // виведе:  "Джаз", "Блюз"
// styles.push("Рок-н-Ролл");                          // додали в кінець "Рок-н-Ролл"
// console.log(styles);                                // виведе:  "Джаз", "Блюз", "Рок-н-Ролл"
// styles[styles.length - 2] = "Класика";              // міняємо передостаннє значення на "Класика"
// console.log(styles);                                // виведе:  "Джаз", "Класика", "Рок-н-Ролл"
// alert ( styles.shift() );                           // видаляємо перше значення масиву "Джаз" і виводимо його alert
// console.log(styles);                                // виведе: "Класика", "Рок-н-Ролл"
// styles.unshift("Реп", "Реггі");                     // додаєм на початок "Реп" та "Реггі" 
// console.log(styles);                                // виведе: "Реп", "Реггі", "Класика", "Рок-н-Ролл"





/*Що виведе цей код? Або чому дорівнює елемент масиву? 
let arr = [1, 2, 3];
let arr2 = arr;
arr2[0] = 5;
alert( arr[0] );
alert( arr2[0] );
А що потрібно зробити, щоб скопіювати масив?   */

// Рішення:
// Через те, що створений arr2 == arr (якщо їх порівняти то виведе true) значить, що будь-які зміни в arr2
// будуть відображатись і в arr, а тому в обох випадках буде виведено 5. 
// Зазначимо, що масиви - це підвид об'єкту. Об'єкт залишається один і той самий
// а в масиві даються на нього лише ссилки. Тому виразом let arr2 = arr ми поєднуємо дві ссилки на один і той самий об'єкт
// Щоб скопіювати один масив в інший, потрібно перебрати усі елементи масиву з якого хочимо зробити копію.
// Так, для копіювання елементів масиву arr в arr2 можемо написати код:
// let arr = [1, 2, 3];
// let arr2 =[];                               // створили новий масив arr2
//     for (let i = 0; i < arr.length; i++)    // перебераємо усі елементи масиву arr для arr2 
//     arr2[i] = arr[i]                        // копіюємо елементи масиву arr в масив arr2
// console.log(arr2);                          // виведеться: (3) [1, 2, 3] - тобто скопіювали елементи самого масиву а не ссилку






/* Під час введення даних про вік вводяться різні типи даних як 45 років - тобто типи: числа та рядки. Написати 
функцію для перевірки введення даних, яка буде виділяти тільки числове значення. Вивести результат в консолі */

// Рішення:
// let testVar = 0;                                            // присвоїли числове значення яке дорівнює 0
// console.log(testVar);                                       // виведе: 0
// testVar = !testVar;                                         // ! - переводить спочатку до логічного-значення, а потім повертає на протилежне; тут 0 переводиться до false а потім на true 
// console.log(testVar);                                       //  виведе: true
// let userAge = prompt("введіть ваш вік", "45 років");
//     let realAge = "";
//     for (let i = 0; i < userAge.length; i++) {
//         if (!isNaN (userAge[i]) && userAge[i] != " ") {     // якщо це не рядок і якщо це не пробіл - продовжити виконання
//             realAge += userAge[i];                          // візьметься цифрове значення = яке перебором береться для кожної цифри 
//     }
// }
// console.log(realAge);                                       // виведе: 45
// console.log(isNaN(userAge[0]));                             // виведе: false
// console.log(isNaN(userAge[3]));                             // виведе: true





/* Написати код для виведення через alert випадкового значення з масиву:
let arr = ["Яблоко", "Апельсин", "Груша", "Лимон"];
Для цього надається код для генерації випадкового цілого числа від min to max включно:
let rand = min + Math.floor(Math.random() * (max + 1 - min));   */ 

// Рішення:
// Для виведення/зчитування будь-якого значення масиву зазначають імя масиву та в [] його індекс;
// А далі ми підставляємо на місце індексу не сам індекс а результат генерації випадкового цілого 
// числа з масиву arr від 1го елементу з 0 індексом до останнього елементу включно з індексом arr.length-1. 
// let arr = ["Яблоко", "Апельсин", "Груша", "Лимон"];
// let rand = Math.floor(Math.random() * arr.length);
// alert( arr[rand] );





/*Написати код для підрахування введених значень у якому:
Запитується по черзі ввести значення, які потім зберігаються у масиві
Завершується введення у разі введення пустого рядка, нечисла чи користувач натисне «Відміна»
При отриманні значення нуль 0 не повинно закінчуватись введення даних; 0 - це дозволене число
Вивести суму усіх введених значень масиву  */

// Рішення:
// let numbers = [];
// while (true) {
//     let value = prompt("Введіть ціле числове значення", 0);
//     if (value === "" || isNaN(value) || value === null)     // перевірка на введення пустого рядка, нечисла чи при натисканні «Відміна»
//     break;
//     numbers.push(+value);
// } 
// let sum = 0;
// for (let i = 0; i < numbers.length; i++) {
//   sum += numbers[i];
// }
// alert( sum );





/*Створити функцію find(arr, value), яка шукає в масиві arr значення value і повертає його індекс, 
якщо знайдено, чи -1, якщо не знайдено.
Наприклад:
arr = ["test", 2, 1.5, false];
find(arr, "test"); // 0
find(arr, 2); // 1
find(arr, 1.5); // 2
find(arr, 0); // -1  */

// Рішення:
// Цей варіант1 HE зовсім правельний !
// let arr = ["test", 2, 1.5, false];
// function find(arr, value) {
//     for (let i = 0; i < arr.length; i++) {
//         if (arr[i] === value) return i;   // вираз порівняння == не розрізняє 0 і false, тому використовують ===
//     }   return -1;                        
// }
// find(arr, "test");
// find(arr, 2);
// find(arr, 1.5);
// find(arr, 0);

// Варіант2 з використанням indexOf
// let arr = ["test", 2, 1.5, false];
// function find(arr, value) {         // створюємо функцію
//     if (arr.indexOf) {              // якщо підтримується браузером; повертає індекс (позицію), на якій знаходиться підрядок чи -1, якщо нічого не знайшов
//         return arr.indexOf(value);  // повертаємо значення якщо є
//     } else {                        // якщо indexOf не підтримується то шукаємо значення тут
//     for (let i = 0; i < arr.length; i++) {
//         if (arr[i] === value) return i;
//     }
//     return -1;
//     }
// }
// // let index = find(arr, "test");    // тут в перемінну записуємо результат функції find
// // alert( index );                   // виведе позицію 0
// // let index = find(arr, 2);         // тут в перемінну записуємо результат функції find
// // alert( index );                   // виведе позицію 1
// let index = find(arr, 0);            // тут в перемінну записуємо результат функції find
// alert( index );                      // виведе -1

// Варіант3 з використанням indexOf та негайною перевіркою підтримки браузером цього методу
// let arr = ["test", 2, 1.5, false];
// const find = (arr, value) => {                    // запускаємо функцію
//     if ([].indexOf) {                             // створюємо пустий масив та одразу перевіряємо чи підтримується метод indexOf браузером
//         return arr.indexOf(value);                // повертаємо значення якщо є
//     } else {                                      // якщо indexOf не підтримується то шукаємо значення тут
//         for (let i = 0; i < arr.length; i++) { 
//             if (arr[i] === value) return i;
//         }
//     }
//     return -1;                                          // тут зпрацює якщо значення в масиві немає
// };
// let index = find(arr, false);                           // тут в перемінну записуємо результат функції find
// console.log(index);                                     // виведе: 3
// let index = find(arr, 1.5);                             // тут в перемінну записуємо результат функції find
// console.log(index);                                     // виведе: 2



/* Створити функцію filterRange(arr, a, b), яка отримує масив чисел і повертає новий масив,
який містить тільки числа з arr та діапазону від a до b. Тобто при перевірці вона має вид
a ≤ arr[i] ≤ b. Функція не повинна міняти arr
Приклад роботи:
let arr = [5, 4, 3, 8, 0];
let filtered = filterRange(arr, 3, 5);
теперь filtered = [5, 4, 3]
arr не змінився  */

// Рішення:
// function filterRange(arr, a, b) {               // називаємо функцію і вказуємо параметри
//     let result = [];                            // створюємо тимчасовий пустий масив
  
//     for (let i = 0; i < arr.length; i++) {      // перебераємо елементи масиву
//       if (arr[i] >= a && arr[i] <= b) {         // задаєм потрібний діапазон для нового масиву так, щоб він не змінився
//         result.push(arr[i]);                    // добавляє елемент в кінець тимчасового масиву (або заповнюємо його)
//       }
//     }
  
//     return result;                              // повертаємо потрібний масив
// }
  
// let arr = [5, 4, 3, 8, 0];
// let filtered = filterRange(arr, 3, 5);
// alert( filtered );




/* Ціле число, більше 1, називається простим, якщо воно не ділиться націло на жодне інше, крім себе и 1.
Дaвній алгоритм «Решето Ератосфена» для пошуку усіх простих чисел до n виглядає ось так по крокам:
крок 1 Створити список послідовних чисел від 2 до n: 2, 3, 4, ..., n.
крок 2 Нехай p=2, це перше просте число.
крок 3 Закреслити усі наступні числа у списку з різницею в p, тобто 2*p, 3*p, 4*p и т.д. У випадку p=2 це буде 4,6,8....
крок 4 Поміняти значення p на пеше незакреслене число після p.
крок 5 Повторити кроки 3-4 поки p2 < n.
крок 6 Усі числа, які залишились незакресленими це числа - прості.
Подивіться також анімацію алгоритма.
Завдання:
Потрібно реалізувати «Решето Ератосфена» в JavaScript, використовуючи масив.
Знайдіть усі прості числа до 100 і виведіть їх суму  */

// Рішення:
// крок 1
// let arr = [];
// for (let i = 2; i < 100; i++) {
//   arr[i] = true
// }
// // крок 2
// let p = 2;
// do {
// // крок 3
//   for (i = 2 * p; i < 100; i += p) {
//     arr[i] = false;
//   }
// // крок 4
//   for (i = p + 1; i < 100; i++) {
//     if (arr[i]) break;
//   }
//   p = i;
// } while (p * p < 100); // крок 5

// // крок 6 (готово)
// // порахувати суму
// let sum = 0;
// for (i = 0; i < arr.length; i++) {
//   if (arr[i]) {
//     sum += i;
//   }
// }
// alert( sum ); виведе: 1060




/* Ми маємо довільний масив чисел, наприклад: arr = [1, -2, 3, 4, -9, 6].
Задача – знайти підмасив (потрібний участок довільного масиву arr), сума елементів якого є максимальною
Створена   функція function getMaxSubSum(arr) повинна повертати тільки цю суму
Наприклад:
getMaxSubSum([-1, 2, 3, -9]) = 5 (сумма елементів на участку від 2 до 3)
getMaxSubSum([2, -1, 2, 3, -9]) = 6 (сумма елементів на участку від 2 до 3)
getMaxSubSum([-1, 2, 3, -9, 11]) = 11 (сумма елементів на участку від 11 до 11)
getMaxSubSum([-2, -1, 1, 2]) = 3 (сумма елементів на участку від 1 до 2)
getMaxSubSum([100, -9, 2, -3, 5]) = 100 (сумма елементів на участку від 100 до 100)
getMaxSubSum([1, 2, 3]) = 6 (усі числа додатні - берем їх усі тобто суму елементів на участку від 1 до 3)
Якщо усі елементи відємні, то не берем жодного елементу і вважаємо суму рівною нулю:
getMaxSubSum([-1, -2, -3]) = 0
Чи можете придумати рішення, яке працює за O(n2), а ліпше за O(n) операцій */

// Рішення:
// Варіант 1:
// Можно просто порахувати для кожного елементу масиву усю суму, яка з нього починається
// Наприклад, для [-1, 2, 3, -9, 11]
// -1                          // Починаючи з  -1
// -1 + 2
// -1 + 2 + 3
// -1 + 2 + 3 + (-9)
// -1 + 2 + 3 + (-9) + 11

// 2                           // Починаючи з  2
// 2 + 3
// 2 + 3 + (-9)
// 2 + 3 + (-9) + 11

// 3                           // Починаючи з  3
// 3 + (-9)
// 3 + (-9) + 11

// -9                          // Починаючи з  -9
// -9 + 11

// 11                          // Починаючи з  11

// Варіант 2:
// Через вкладений цикл, який на зовнішньому рівні бігає по елементам масиву, 
// а на внутрішньому – формує усі суми елементів, які починаються з вибраної позиції
// function getMaxSubSum(arr) {
//     let maxSum = 0;                           // якщо зовсім не брати елементів то сума == 0
  
//     for (let i = 0; i < arr.length; i++) {   // сформували зовнішній цикл, який бігає по елементам масиву (перебирає елемент за елементом)
//       let sumFixedStart = 0;                 // створили проміжне значення куда буде присвоюватись сума елементів починаючи з вибраної позиції
//       for (let j = i; j < arr.length; j++) { // сформували внутріішній цикл, який формує суму елементів, починаючи з вибраної позиції
//         sumFixedStart += arr[j];             // підрахували проміжне значення суми елементів з вибраної позиції
//         maxSum = Math.max(maxSum, sumFixedStart); // підрахували максимальну суму елементів з урахуванням  потрібного участка масиву
//       }
//     }
  
//     return maxSum;
// }
// alert( getMaxSubSum([-1, 2, 3, -9]) );          // виведе: 5
// alert( getMaxSubSum([-1, 2, 3, -9, 11]) );      // виведе: 11
// alert( getMaxSubSum([-2, -1, 1, 2]) );          // виведе: 3
// alert( getMaxSubSum([1, 2, 3]) );               // виведе: 6
// alert( getMaxSubSum([100, -9, 2, -3, 5]) );     // виведе: 100
// Проте таке рішення має оцінку складності O(n2), тобто у разі збільшення елементів масиву в 2 рази, алгоритм потребує
// в 4 рази більше часу. На великих масивах (1000, 10000 і більше елементів) такий алгоритм може призвести до серйозних «тормозів»

// Варіант 3:
// Щоб уникнути «тормозів» із великими масивами будемо йти по масиву і накопичувати в тимчасовій перемінній s поточну 
// частину суми (часткову суму). Якщо у якийсь момент часткова сума s (не елемент) отримає відємне значення, то ми просто присвоїмо s=0.
// Адже тут стверджується, що максимум зі всіх значень яку отримає змінна s, і буде відповіддю на задачу
// function getMaxSubSum(arr) {
//     let maxSum = 0,
//     partialSum = 0;
//     for (var i = 0; i < arr.length; i++) {
//       partialSum += arr[i];
//       maxSum = Math.max(maxSum, partialSum);
//       if (partialSum < 0) partialSum = 0;
//     }
//     return maxSum;
// }
// alert( getMaxSubSum([-1, 2, 3, -9]) );         // виведе: 5
// alert( getMaxSubSum([-1, 2, 3, -9, 11]) );     // виведе: 11
// alert( getMaxSubSum([-2, -1, 1, 2]) );         // виведе: 3
// alert( getMaxSubSum([100, -9, 2, -3, 5]) );    // виведе: 100
// alert( getMaxSubSum([1, 2, 3]) );              // виведе: 6
// alert( getMaxSubSum([-1, -2, -3]) );           // виведе: 0