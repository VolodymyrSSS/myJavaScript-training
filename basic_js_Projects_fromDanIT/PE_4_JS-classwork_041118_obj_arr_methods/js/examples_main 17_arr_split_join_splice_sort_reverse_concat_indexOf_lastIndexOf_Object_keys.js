// Массивы: 
// Есть встроенные методы массивов в JavaScript, основные:

// push/pop, shift/unshift, splice – для добавления и удаления элементов
// join/split – для преобразования строки в массив и обратно
// slice – копирует участок массива.
// sort – для сортировки массива. Если не передать функцию сравнения – сортирует элементы как строки
// reverse – меняет порядок элементов на обратный
// concat – объединяет массивы
// indexOf/lastIndexOf – возвращают позицию элемента в массиве (не поддерживается в IE8-)
// Object.keys(obj) возвращает массив свойств объекта




// split(s)
// метод split(s), позволяет превратить строку в массив, разбив ее по разделителю s
// В примере ниже таким разделителем s является строка из запятой и пробела
// let names = "Маша, Петя, Марина, Василий";
// let arr = names.split(", ");
// for (let i = 0; i < arr.length; i++) {
//   alert( "Вам сообщение " + arr[i] );       // выведет по-очереди: Вам сообщение Маша;  Вам сообщение Петя; ... Марина, ... Василий
// }
// У метода split есть необязательный второй аргумент – ограничение на количество элементов в массиве
// Если их больше, чем указано – остаток массива будет отброшен, пример:
// alert( "a,b,c,d".split(',', 2) );               // выведет: a,b только
// Вызов split с пустой строкой разобьёт по буквам:
// let str = "тест";
// alert( str.split('') );                         // выведет: т,е,с,т



// join
// Вызов arr.join(str) делает в точности противоположное split. Он берет массив и склеивает его в строку, используя 'str'; как разделитель
// let arr = ['Маша', 'Петя', 'Марина', 'Василий'];
// let str = arr.join(';');                        
// alert( str );                                   // выведет: Маша;Петя;Марина;Василий
// если new Array + join = Повторение строки
// Пример кода для повторения строки 3 раза:
// alert( new Array(4).join("ля") );  // выведет: ляляля (3 раза т.к. последний элемент массива = n-1 и что-бы вивести 3 раза надо уакзывать 4)
// Как видно, new Array(4) делает массив без элементов длины 4, который join объединяет в строку, вставляя между его элементами строку "ля"
// В результате, так как элементы пусты, получается повторение строки. Такой вот небольшой трюк.



// Удаление из массива
// Так как массивы являются объектами, то для удаления ключа можно воспользоваться обычным delete:
// let arr = ["Я", "иду", "домой"];
// delete arr[1];                                    // значение с индексом 1 удалено
// но  масив теперь имеет вид arr = ["Я", undefined, "домой"]; Мы видим что образовалась «дырка»
// alert( arr[1] );                                  // undefined
// Это потому, что оператор delete удаляет пару «ключ-значение». Это – все, что он делает. Обычно же при удалении из массива мы хотим,
// чтобы оставшиеся элементы сдвинулись и заполнили образовавшийся промежуток. Поэтому для удаления используются специальные методы: 
// из начала – shift, с конца – pop, а из середины – splice



// splice
// Метод splice – это универсальный раскладной нож для работы с массивами. Умеет все: удалять элементы, вставлять элементы, заменять
// элементы – по очереди и одновременно. Его синтаксис:
// arr.splice(index[, deleteCount, elem1, ..., elemN])    // Этот код значит - удалить deleteCount элементов, начиная с номера index,
// а затем вставить elem1, ..., elemN на их место. Он также может возвращать массив из удалённых элементов

// Начнём с удаления:
// let arr = ["Я", "изучаю", "JavaScript"];
// arr.splice(1, 1);                            // начиная с позиции 1, удалить 1(один) элемент
// alert( arr );                                // выведет: ["Я", "JavaScript"]

// В следующем примере мы удалим 3 элемента и вставим другие на их место:
// let arr = ["Я", "сейчас", "изучаю", "JavaScript"];
// arr.splice(0, 3, "Мы", "изучаем")            // удалить 3 первых элемента и добавить другие вместо них
// alert( arr )                                 // выведет: ["Мы", "изучаем", "JavaScript"]

//Здесь  splice возвращает массив из удаленных элементов:
// let arr = ["Я", "сейчас", "изучаю", "JavaScript"];
// let removed = arr.splice(0, 2);              // удалить 2 первых элемента
// alert( removed );                            // выведет: "Я", "сейчас" - это массив из удаленных элементов

// Метод splice также может вставлять элементы без удаления, для этого достаточно установить deleteCount в 0:
// let arr = ["Я", "изучаю", "JavaScript"];
// arr.splice(2, 0, "сложный", "язык");          // с позиции 2 удалить 0  вставить "сложный", "язык"
// alert( arr );                                 // выведет: "Я", "изучаю", "сложный", "язык", "JavaScript"

// Допускается использование отрицательного номера позиции, которая в этом случае отсчитывается с конца:
// let arr = [1, 2, 5]
// arr.splice(-1, 0, 3, 4);   // начиная с позиции (индексом) -1 (перед последним элементом) удалить 0 элементов, затем вставить числа 3 и 4
// alert( arr );                                 //выведет: 1,2,3,4,5



// slice
// Метод slice(begin, end) копирует участок массива от begin до end, не включая end. Исходный массив при этом не меняется.
// let arr = ["Почему", "надо", "учить", "JavaScript"];
// let arr2 = arr.slice(1, 3);                    // элементы 1, 2 (не включая 3)
// alert( arr2 );                                 // выведет: надо, учить
// Аргументы ведут себя так же, как и в строковом slice: eсли не указать end – копирование будет до конца массива:
// let arr = ["Почему", "надо", "учить", "JavaScript"];
// alert( arr.slice(1) );                        // выведет: надо,учить,JavaScript - взять все элементы, начиная с номера 1  
// Можно использовать отрицательные индексы, они отсчитываются с конца:
// let arr = ["Почему", "надо", "учить", "JavaScript"]; 
// let arr2 = arr.slice(-2);                     // копировать от 2-го элемента с конца и дальше, имеем: [ "учить", "JavaScript"];
// Если вообще не указать аргументов – скопируется весь массив:
// let fullCopy = arr.slice();                  // имеем ["Почему", "надо", "учить", "JavaScript"];
// Синтаксис метода slice одинаков для строк и для массивов. Тем проще его запомнить.



// sort(fn)
// Метод sort() сортирует массив на месте
// let arr = [ 1, 2, 15 ];
// arr.sort();
// alert( arr );                                // выведет: 1, 15, 2 - Не заметили ничего странного в этом примере?
// Порядок стал 1, 15, 2 Это произошло потому, что по умолчанию sort сортирует, преобразуя элементы к строке !!!
// Поэтому и порядок у них строковый, ведь "2" > "15"

// Для указания своего порядка сортировки в метод arr.sort(fn) нужно передать функцию fn от двух элементов, которая умеет сравнивать их
// Если эту функцию не указать, то элементы сортируются как строки
// Например, укажем эту функцию явно, отсортируем элементы массива как числа:
// function compareNumeric(a, b) {
//   if (a > b) return 1;
//   if (a < b) return -1;
// }
// let arr = [ 1, 2, 15 ];
// arr.sort(compareNumeric);
// alert(arr);                                    // выведет:1, 2, 15 
// Обратите внимание, мы передаём в sort() именно саму функцию compareNumeric, без вызова через скобки
// Был бы ошибкой следующий код: arr.sort( compareNumeric() );  так как oн не сработает!
// функция, передаваемая sort, должна иметь два аргумента. Алгоритм сортировки, встроенный в JavaScript, будет передавать ей
// для сравнения элементы массива. Она должна возвращать:
// Положительное значение, если a > b,
// Отрицательное значение, если a < b,
// Если равны – можно 0, но вообще – не важно, что возвращать, если их взаимный порядок не имеет значения

// Функцию compareNumeric для сравнения элементов-чисел можно упростить до одной строчки.
// function compareNumeric(a, b) {
//   return a - b;
// }
// Эта функция вполне подходит для sort, так как возвращает положительное число, если a > b, 
// отрицательное, если наоборот, и 0, если числа равны.

// В методе sort, внутри самого интерпретатора JavaScript, реализован универсальный алгоритм сортировки
// Он решает, какие пары элементов и когда сравнивать, чтобы отсортировать побыстрее
// Мы даём ему функцию – способ сравнения, дальше он вызывает её сам
// Кстати, те значения, с которыми sort вызывает функцию сравнения, можно увидеть, если вставить в неё alert
// [1, -2, 15, 2, 0, 8].sort(function(a, b) {
//  alert( a + " <> " + b );                   // выведет по очереди: 1 <> -2   -2 <> 15    15 <> 2      2 <> 0      0 <> 8  
// });



// reverse
// Метод arr.reverse() меняет порядок элементов в массиве на обратный.
// let arr = [1, 2, 3];
// arr.reverse();
// alert( arr );                              // выведет: 3,2,1



// concat
// Метод arr.concat(value1, value2, … valueN) создаёт новый массив, в который копируются элементы из arr, а также value1, value2, ... valueN.
// let arr = [1, 2];
// let newArr = arr.concat(3, 4);
// alert( newArr );                            // выведет: 1,2,3,4
// У concat есть одна забавная особенность. Если аргумент concat – массив, то concat добавляет элементы из него.  Например:
// let arr = [1, 2];
// let newArr = arr.concat([3, 4], 5);         // то же самое, что arr.concat(3,4,5)
// alert( newArr );                            // выведет:  1,2,3,4,5



// indexOf/lastIndexOf
// Эти методы не поддерживаются в IE8-. Для их поддержки подключите библиотеку ES5-shim.
// Метод «arr.indexOf(searchElement[, fromIndex])» возвращает номер (индекс) элемента searchElement в массиве arr или -1, если его нет
// Поиск начинается с номера fromIndex, если он указан. Если нет – с начала массива.
// Для поиска используется строгое сравнение ===.      Например:
// let arr = [1, 0, false];
// alert( arr.indexOf(0) );                      // выведет: 1
// alert( arr.indexOf(false) );                  // выведет: 2
// alert( arr.indexOf(null) );                   // выведет: -1
// Как вы могли заметить, по синтаксису он полностью аналогичен методу indexOf для строк.
// Метод «arr.lastIndexOf(searchElement[, fromIndex])» ищет справа-налево: с конца массива или с номера fromIndex, если он указан.

// Методы indexOf/lastIndexOf осуществляют поиск перебором!
// Если нужно проверить, существует ли значение в массиве – его нужно перебрать! Только так. Внутренняя реализация indexOf/lastIndexOf
// осуществляет полный перебор, аналогичный циклу for по массиву. Чем длиннее массив, тем дольше он будет работать

//Рассмотрим задачу – есть коллекция строк, и нужно быстро проверять: есть ли в ней какой-то элемент 
// Массив для этого не подходит из-за медленного indexOf. Но подходит объект! Доступ к свойству объекта осуществляется очень быстро,
// так что можно сделать все элементы ключами объекта и проверять, есть ли уже такой ключ
// Например, организуем такую проверку для массива коллекции строк "div", "a" и "form":
// let store = {};                                // объект для коллекции
// let items = ["div", "a", "form"];              // создали массив с элементами "div", "a" и "form"
// for (let i = 0; i < items.length; i++) {
//   let key = items[i];                          // для каждого элемента массива создаём свойство объекта
//   store[key] = true;                           // значение свойства объекта здесь не важно
// }
// Теперь для проверки, есть ли ключ key, достаточно выполнить if (store[key]). Если есть – можно использовать значение, если нет – добавить.
// Такое решение работает только со строками, но применимо к любым элементам, для которых можно вычислить строковый «уникальный ключ».



// Object.keys(obj)
// Ранее мы говорили о том, что свойства объекта можно перебрать в цикле for..in
// Если мы хотим работать с ними в виде массива, то к нашим услугам – замечательный метод Object.keys(obj). Он поддерживается везде, кроме IE8-:
// let user = {
//   name: "Петя",
//   age: 30
// }
// let keys = Object.keys(user);
// alert( keys );                                 // выведет: name, age - здесь возвращается массив свойств объекта







//                                                          П Р И К Л А Д И






/* Є довільний перший масив з іменами. Написати функцію, яка буде повертати новий масив з іменами  
розположеному у зворотньому порядку. Вивести у консолі кількість елементів першого масиву, потім
вивести результат роботи функції  */

// // Рішення:
// let reversArr = (arr) => {                                     // створюємо функцію під назвою reversArr яка буде повертати новий масив 
//     let newArr = [];                                           // створюємо новий масив у якому мають бути елементи у зворотньому порядку 
//     for(let i = arr.length - 1, j = 0; i >= 0; i--, j++) {     // робимо перебори елементів: і - для першого масиву починаючи з кінця та j - для нового масиву - з початку 
//         newArr[j] = arr[i];                                    // присвоюємо єлементи першого масиву, які перебрані з кінця, до нового масиву
//     }
//     return newArr;                                             // повертаємо новий масив
// }
// let arrGirls = ["Оля", "Женя", "Світлана", "Юля", "Оксана", "Надія"];  // задаємо змінній arrGirls перший масив з іменами
// console.log(arrGirls.length);                                          // виведе: 6 - кількість елементів першого масиву
// console.log(reversArr(arrGirls));                                      // виведе: ["Надія", "Оксана", "Юля", "Світлана", "Женя", "Оля"] - 
//                                                                        // це є результат роботи функції reversArr - новий масив з елементами у зворотньому порядку




/* Написати функцію, яка буде отримувати рядок з 5 слів і після роботи повертати найдовше слово */

// Рішення:
let strLongest = (str) => {                             // створюємо функцію під назвою strLongest яка буде повертати елемент-рядок
  let result = "";                                      // створюємо початкову перемінну якій буде потім присвоюватись проміжні результати в ході порівняння елементів
  let arr = str.split(" ");                             // створюємо масив якому присвоюємо значення отримані в результаті перетворення рядка у масив методом str.split і роздільником- пробіл
  let arrLength = arr.length;                           // створюємо перемінну arrLength якій присвоюється значення довжини массиву arr
  for(let i = 0; i < arrLength; i++){                   // перебираємо елементи і масиву для пошуку найдовшого слова
    if (result.length < arr[i].length) {                // якщо довжина і-елемента масиву більша від довжини проміжного результату 
      result = arr[i];                                  // то присвоїти як проміжний результат цей взятий елемент масиву і продовжити роботу
    }                                                   // в інакшому разі
  }
  return result;                                        // повертаємо результат роботи функції - елемент-рядок (знайдене найдовше слово)
};
let strName = "Франкфурт-на-Майні Алма-Ата Аддіс-Абеба Нью-Йорк Новгород-Волинський";
console.log(strLongest(strName));




// вивести 3 з 1го
// let fio = prompt("Ваше ФИО");
// let [lastName, name, patronimic] = splitFio(fio);
// // let arrFio = splitFio(fio);
// // let lastName = arrFio[0];
// // let name = arrFio[1];
// // let patronimic = arrFio[2];
// console.log(lastName);
// console.log(name);
// console.log(patronimic);

// function splitFio(str) {
//     arrFio = str.split(" ");
//     return arrFio;
// }





/*  В об'єкті є властивісь className, яка містить список «класів» – слів, розділених пробілом:
let obj = {
  className: 'open menu'
}
Потрібно створити функцію addClass(obj, cls), яка додасть в список клас cls, але тільки якщо його там немає:
Для перевірки, ось результати роботи такої функції:
addClass(obj, 'new');    // obj.className='open menu new'
addClass(obj, 'open');   // без изменений (клас вже існує)
addClass(obj, 'me');     // obj.className='open menu new me'
alert( obj.className );  // "open menu new me"
P.S. Функція не повинна додавати лишніх пробілів

// Рішення:
// Для цього потрібно спочатку застосувати перетворення obj.className у масив при допомозі split
// Потім вже у масиві можна перевірити наявність класу і якщо його немає то добавити
function addClass(obj, cls) {
  let classes = obj.className ? obj.className.split(' ') : [];

  for (var i = 0; i < classes.length; i++) {
    if (classes[i] == cls) return; // класс уже есть
  }

  classes.push(cls); // добавить

  obj.className = classes.join(' '); // и обновить свойство
}

var obj = {
  className: 'open menu'
};

addClass(obj, 'new');
addClass(obj, 'open');
addClass(obj, 'me');
alert(obj.className) // open menu new me
P.S. «Альтернативный» подход к проверке наличия класса вызовом obj.className.indexOf(cls) был бы неверным. В частности, он найдёт cls = "menu" в строке классов obj.className = "open mymenu".

P.P.S. Проверьте, нет ли в вашем решении присвоения obj.className += " " + cls. Не добавляет ли оно лишний пробел в случае, если изначально obj.className = ""?

/* В нас є довільний масив goods. Напишіть код щоб додати в кінець цього масиву значення «Комп'ютер»  */






/* Створіть массив stylesаннього значення повинен працювати для масивів будь-якої довжини. Потім видаліть
перше значення масиву і виведіть його за допомогою alert. І на кінець, додайте на початок значення «Реп» та «Реггі»  */

// Рішення:





/* Під час введення даних про вік вводяться різні типи даних як 45 років - тобто типи: числа та рядки. Написати 
код для перевірки введення різних типів даних, але виділити потрібно тільки число та вивести його в консолі */

// Рішення:






