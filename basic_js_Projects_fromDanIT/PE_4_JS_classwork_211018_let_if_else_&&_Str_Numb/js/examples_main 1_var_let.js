// Обьявление переменных

// var admin, name; // две переменных через запятую
// name = "Василий";
// admin = name;
// alert( admin ); // "Василий"

// let var1;
// let var2 = 200;
// console.log(var2 - var1); // NaN

// let var3 = null;
// let var4 = 2000;
// console.log(var4 - var3); // 2000

// Правильное название переменных
// var ourPlanetName = "Земля"; // буквально "название нашей планеты"
// var userName = "Петя"; // "имя посетителя"

// 5 «примитивных» типов данных
// var n = 123;
// n = 12.345;

// var str = "Мама мыла раму";
// str = 'Одинарные кавычки тоже подойдут';

// var checked = true; // поле формы помечено галочкой
// checked = false;    // поле формы не содержит галочки

// var age = null; // имеет смысл «ничего» или «значение неизвестно». Kод говорит о том, что возраст age неизвестен.

// var x;
// alert( x ); // имеет смысл «значение не присвоено». Если переменная объявлена, но в неё ничего не записано, то её значение и есть undefined

// // шестой тип данных: «объекты»
// var user = { name: "Вася" };

// // Оператор typeof x позволяет выяснить, какой тип находится в x, возвращая его в виде строки:

// typeof undefined // "undefined"

// typeof 0 // "number"

// typeof true // "boolean"

// typeof "foo" // "string"

// typeof {} // "object"

// typeof null // "object"  - это официально признанная ошибка. На самом деле это отдельный тип данных

// typeof function(){} // "function"  - функции не являются отдельным базовым типом в JS, а подвидом объектов

// var a = "моя" + "строка"; // если бинарный оператор '+' применить к строкам, то он их объединяет в одну
// alert( a ); // моястрока // говорят, что «плюс производит конкатенацию (сложение) строк»

// // Унарный, то есть применённый к одному значению, плюс ничего не делает с числами
// alert( +1 ); // 1
// alert( +(1 - 2) ); // -1
// //  его «побочный эффект» – преобразование значения в число
// var apples = "2";
// var oranges = "3";
// alert( +apples + +oranges ); // 5, число, оба операнда предварительно преобразованы в числа

// // если в выражении есть несколько операторов – порядок их выполнения определяется приоритетом
// // каждому оператору задан числовой приоритет. Тот, у кого число больше – выполнится раньше. Если приоритет одинаковый, то порядок выполнения – слева направо.

// // Инкремент ++ увеличивает на 1
// var i = 2;
// i++;      // называется «постфиксная форма», более короткая запись для i = i + 1
// alert(i); // 3

// // Декремент -- уменьшает на 1
// var i = 2;
// i--;      // префиксная форма, более короткая запись для i = i - 1
// alert(i); // 1

// // Постфиксная форма i++ отличается от префиксной ++i тем, что возвращает старое значение, бывшее до увеличения
// var i = 1;
// var a = i++;
// alert(a); // 1
// // когда мы хотим не только увеличить/уменьшить переменную, но и использовать результат в том же выражении
// var i = 1;
// var a = ++i;
// alert(a); // 2

// var i = 1;
// alert( 2 * i++ ); // 2,  выполнился раньше но значение вернул старое
// alert( i ); // 2
// alert( 2 * i++ ); // 4
// alert( i ); // 3


// Побитовые операторы в JS работают с 32-битными целыми числами в их двоичном представлении.
// a = 0;  // 00000000000000000000000000000000
// a = 1;  // 00000000000000000000000000000001
// a = 2;  // 00000000000000000000000000000010
// a = 3;  // 00000000000000000000000000000011
// a = 255;// 00000000000000000000000011111111
// Побитовые операторы:
// AND(и) ( & ) // Результат a & b равен единице только когда оба бита a и b равны единице.
// OR(или) ( | ) // Результат a | b равен 1, если хотя бы один бит из a,b равен 1.
// XOR(побитовое исключающее или) ( ^ ) // a Исключающее ИЛИ b равно 1, если только a=1 или только b=1, но не оба одновременно// 1 ^ 1 = 0
// NOT(не) ( ~ ) // Производит операцию НЕ над каждым битом, заменяя его на обратный ему.
// LEFT SHIFT(левый сдвиг) ( << )
// RIGHT SHIFT(правый сдвиг) ( >> )
// ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( >>> )


// Оператор a << b, сдвигая биты, по сути умножает a на 2 в степени b
// alert( 1 << 2 ); // 1*(2*2) = 4
// alert( 1 << 3 ); // 1*(2*2*2) = 8
// alert( 3 << 3 ); // 3*(2*2*2) = 24

// Вспомогательные функции parseInt, toString
// parseInt("11000", 2) – переводит строку с двоичной записью числа в число
// n.toString(2) – получает для числа n запись в 2-ной системе в виде строки

// var access = parseInt("11000", 2); // получаем число из строки
// alert( access ); // 24, число с таким 2-ным представлением

// var access2 = access.toString(2); // обратно двоичную строку из числа
// alert( access2 ); // 11000


// битовые операции отбрасывают десятичную часть, то их можно использовать для округления
// alert( ~~12.345 ); // 12
// alert( 12.345 ^ 0 ); // 12
// alert(12.3 * 14.5 ^ 0); // (=178) "12.3 умножить на 14.5 и округлить"

// Проверка на −1 // при таком формате представления числа -n = ~n + 1. Или, если перенести единицу: ~n = -(n+1).
// alert( ~3 ); // -4
// alert( ~-1 ); // 0

// ~n == 0 только если n == -1 Поэтому можно легко проверить равенство n == -1:
// var n = -1;
// if (~n) { // не сработает, т.к. ~n = -(-1+1) = 0
//   alert( "...ничего не выведет..." );
// }
// var n = 5;
// if (~n) { // сработает, т.к. ~n = -(5+1) = -6
//   alert( "n не -1" ); // выведет!
// }
// Проверка на -1 пригождается, например, при поиске символа в строке. 
// Вызов str.indexOf("подстрока") возвращает позицию подстроки в str, или -1 если не нашёл
// var str = "Проверка";
// if (~str.indexOf("верка")) { // Сочетание "if (~...indexOf)" читается как "если найдено"
// alert( 'найдено!' );
// }

// Сокращенная арифметика с присвоением
// Часто нужно применить оператор к переменной и сохранить результат в ней же
// var n = 2;      // или то же     var n = 2;
// n = n + 5;      //               n += 5; // теперь n=7 (работает как n = n + 5)
// n = n * 2;      //               n *= 2; // теперь n=14 (работает как n = n * 2)
// alert( n );     // выведет: 14

// Oператоры сравнения:
// Больше/меньше: a > b, a < b.
// Больше/меньше или равно: a >= b, a <= b.
// Равно a == b. Для сравнения используется два символа равенства '='. Один символ a = b означал бы присваивание.
// «Не равно». В математике он пишется как ≠, в JavaScript – знак равенства с восклицательным знаком перед ним !=.
// логическиe значения:
// true – имеет смысл «да», «верно», «истина».
// false – означает «нет», «неверно», «ложь»
// alert( 2 > 1 ); // true, верно
// alert( 2 == 1 ); // false, неверно
// alert( 2 != 1 ); // true
// let a = true; // присваивать явно
// let b = 3 > 4; // или как результат сравнения
// alert( b ); // false
// alert( a == b ); // (true == false) неверно, выведет false

//Положение имеет значение ! т.е сравнивая положение буквы/строки в книге - код больше у той которая дальше в книге по алфавиту 
// т.е.на большей странице
// alert( 'Б' > 'А' ); // true; у каждого символа – свой номер (код); код у символа Б больше, чем у А
// alert( 'Банан' > 'Анна' ); // true, т.к. eсли первая буква первой строки больше – значит первая строка больше, независимо от остальных симв
// alert( 'Вася' > 'Ваня' ); // true, т.к. 'с' > 'н'; сравнение дойдёт до третьей буквы
// alert( 'Привет' > 'Прив' ); // true, так как 'е' больше чем "ничего"

// Pегистр имеет значение !
// alert( 'а' > 'Я' ); // true, строчные буквы больше прописных 

// Числа, полученные в виде строк сравнивать нельзя, результат будет неверен
// alert( "2" > "14" ); // true, но это неверно, ведь 2 не больше 14 тут строки сравниваются посимвольно, а первый символ '2' больше '1'
// alert( +"2" > +"14" ); // false, теперь правильно

// сравнении значений разных типов
// alert( '2' > 1 ); // true, сравнивается как 2 > 1
// alert( '01' == 1 ); // true, сравнивается как 1 == 1
// alert( false == 0 ); // true, false становится числом 0
// alert( true == 1 ); // true, так как true становится числом 1

// Для проверки равенства без преобразования типов используются операторы строгого равенства === (тройное равно) и !==; 
// Если тип разный, то они всегда возвращают false
// alert( 0 == false ); // true, оператор == не может отличить 0 от false (пo типy)
// alert( '' == false ); // true
// alert( 0 === false ); // false, т.к. типы различны

// При преобразовании в число null становится ---> 0 
// При преобразовании в число undefined становится ---> NaN

// Но null и undefined обрабатываются особым образом, значения null и undefined равны == друг другу и не равны чему бы то ни было ещё !
// alert( null > 0 ); // false, при преобразовании в число null становится 0
// alert( null == 0 ); // false, null и undefined равны == друг другу и не равны чему бы то ни было ещё
// alert(null >= 0); // true, обрабатываются особым образом
// Значение undefined вообще нельзя сравнивать
// Значение NaN по стандарту устроено так, что сравнения ==, <, >, <=, >= и даже === с ним возвращают false.
// alert( undefined > 0 ); // false, undefined при преобразовании к числу даёт NaN
// alert( undefined < 0 ); // false, undefined при преобразовании к числу даёт NaN
// alert( undefined == 0 ); // false,  undefined равно лишь null или себе и ничему другому




//                                                           П Р И К Л А Д И



// Чи зрозуміло чому такий результат?
// 'use strict';
// var a = 1, b = 1, c, d;
    
// c = ++a; alert(c); // 2
// d = b++; alert(d); // 1
    
// c = (2+ ++a); alert(c); // 5
// d = (2+ b++); alert(d); // 4
    
// alert(a); // 3
// alert(b); // 3


// Чому дорівнює Х ?
// var a = 2;
// var x = 1 + (a *= 2); // 5

// Чому побітові операції не змінюють число? Що вони роблять?
alert( 123 ^ 0 ); // 123 - Операція a^b ставить біт результата в 1, якщо на відповідній бітовій позиції в a чи b (але не одночасно) стоїть 1
alert( 0 ^ 123 ); // 123 - Так як в 0 всюди стоять нулі, то біти берутся в точності як у другому аргументі
alert( ~~123 ); // 123 - Перше побітове НЕ ~ перетворює 0 в 1, а 1 в 0. А друге НЕ перетворює його ще раз, в результаті стало як було

// Напишите функцию isInteger(num), которая возвращает true, если num – целое число, иначе false
// 'use strict';
//     function isInteger(num) {
//       return (num ^ 0) === num;
//     }
    
//     alert( isInteger(1) ); // true
//     alert( isInteger(1.5) ); // false
//     alert( isInteger(-0.5) ); // false