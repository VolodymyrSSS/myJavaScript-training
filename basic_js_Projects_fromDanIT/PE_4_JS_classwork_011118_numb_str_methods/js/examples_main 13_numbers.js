// тип Number
// Все числа в JavaScript, как целые так и дробные, имеют тип Number 
// и хранятся в 64-битном формате IEEE-754, также известном как 
// «double precision». В JavaScript есть обычные числа и три специальных 
// числовых значения: NaN, Infinity и -Infinity

// В JavaScript можно записывать числа не только в десятичной, но и в 
// шестнадцатеричной (начинается с 0x) системе счисления:
// alert( 0xFF ); // выведет: 255 в шестнадцатиричной системе
// Также доступна запись в «научном формате» (ещё говорят «запись с 
// плавающей точкой»), который выглядит как <число>e<количество нулей>
// Например, 1e3 – это 1 с 3 нулями, то есть 1000;          
// или так: alert( 3e5 ); // выведет: 300000
// Если количество нулей отрицательно, то число сдвигается вправо за 
// десятичную точку, так что получается десятичная дробь:
// alert( 3e-5 ); // 0.00003 - 5 нулей, включая начальный ноль, 
// здесь 3 сдвинуто 5 раз вправо, за десятичную точку


// Infinity
// Деление на ноль  - При делении на очень-очень маленькое число должно 
// получиться очень большое, в JS это будет Infinity 
// alert( 1 / 0 ); // выведет: Infinity, а не ошибка как в матемматике
// alert( 12345 / 0 ); // выведет: Infinity
// Infinity – особенное численное значение, которое ведет себя в точности 
// как математическая бесконечность ∞
// Бывает и минус бесконечность -Infinity: 
// alert( -1 / 0 ); // выведет: -Infinity
// Infinity больше любого числа: 
// alert( Infinity > 1234567890 ); // выведет: true
// Добавление к бесконечности не меняет её: 
// alert( Infinity + 5 == Infinity ); // выведет: true
// Бесконечность можно присвоить и в явном виде: var x = Infinity
// Бесконечность можно получить также, если сделать ну очень большое 
// число (количество разрядов в двоичном представлении не помещается 
// в соответствующую часть стандартного 64-битного формата), например:
// alert( 1e500 ); // Infinity


// NaN (Not-A-Number)
// Якщо математична операція не може бути виконана, то повертається
// спеціальне значение NaN. Наприклад, ділення 0/0 з математичного погляду
// є невизначеною, тому в JS його результат NaN: alert( 0 / 0 ); // NaN
// Немає математичних операцій в JavaScript що можуть призвести до помилки
// чи 'завалити' программу. В гіршому випадку результат будет NaN.
// NaN володіє наступними властивостями: 
// Значення NaN – є єдиним у своєму роді, котре не дорівнює нічому, 
// включаючи самого себе:
// if (NaN == NaN) alert( "==" ); // нічого не виведе
// або if (NaN === NaN) alert( "===" ); // не спрацює
// Значення NaN можна перевірити спеціальною функцією isNaN(n), котра 
// конвертує спочатку аргумент до числа і потім повертає true, якщо
// отримано NaN та false – для будь-якого іншого значення. Ось приклад:
// var n = 0 / 0; alert( isNaN(n) ); // виведе: true
// alert( isNaN("12") ); // виведе: false, бо рядок був конвертований до
// звичайного числа 12.
// Якщо аргумент не є числом, то він автоматично претворюється на число,
// і це можна використовувати для перевірки значення на рівність самому
// собі, а іменно: якщо не дорівнює – то NaN:
// var n = 0 / 0; if (n !== n) alert( 'n = NaN!' ) // виведе: n = NaN! 
// var n = 25 / 5; if (n !== n) alert( 'n = NaN!' ) // виведе: true 
// Але з цих двох варіантів перевірки на NaN ліпше використовувати
// (isNaN(n)) замість (n !== n). 
// Значення NaN 'прилипається'. Будь-яка операція з NaN повертає NaN
// alert( NaN + 1 ); // виведе: NaN


// isFinite(n)
// если мы хотим от посетителя получить «обычнoе» число, то Infinity или 
// NaN нам не подходят. Для того чтобы отличить «обычные» числа от таких 
// специальных значений, существует функция isFinite.
// Функция isFinite(n) преобразует аргумент к числу и возвращает true, 
// если это не NaN/Infinity/-Infinity:
// alert( isFinite(1) ); // true
// alert( isFinite(Infinity) ); // false
// alert( isFinite(NaN) ); // false


// Большинство арифметических операций и математических функций преобразуют
// значение в число автоматически
// alert( '12.34' / "-2" ); // выведет:-6.17
// Для того чтобы сделать это явно, обычно перед значением ставят унарный 
// плюс '+': var s = "12.34";
// alert( +s ); // выведет:12.34
// При этом, если строка не является в точности числом, то результат будет
// NaN: alert( +"12test" ); // NaN
// Пробельные символы в начале и в конце строки - игнорируются:
// alert( +"  -12" ); // выведет:-12
// alert( +" \n34  \n" ); // выведет:34, перевод строки \n является 
// пробельным символом
// alert( +"" ); // выведет:0, пустая строка становится нулем
// alert( +"1 2" ); // выведет:NaN, пробел посередине числа - выведет ошибку


// parseInt / parseFloat
// В мире HTML/CSS многие значения не являются в точности числами. 
// Например метрики CSS: -12px или 10pt
// Оператор '+' для таких значений возвратит NaN: alert(+"12px") // выведет:NaN
// Для удобного чтения таких значений существует функция parseInt:
// alert( parseInt('12px') ); // выведет:12
// Функция parseInt и ее аналог parseFloat преобразуют строку в число 
// символ за символом, пока это возможно (при возникновении ошибки 
// возвращается число, которое получилось) при этом:
// parseInt - преобразует в целое число, a  parseFloat - в дробное, например: 
// alert( parseInt('12px') ) // выведет:12, ошибка на символе 'p'
// alert( parseFloat('12.3.4') ) // выведет:12.3, ошибка на второй точке
// Конечно, существуют ситуации, когда parseInt/parseFloat возвращают NaN.
// Это происходит при ошибке на первом же символе:
// alert( parseInt('px12') ); // выведет:NaN
// Функция parseInt также позволяет указать систему счисления, то есть
// считывать числа, заданные в шестнадцатиричной и других системах 
// счисления:    alert( parseInt('FF', 16) ); // выведет:255


// Проверка на число
// Для проверки строки на число можно использовать функцию isNaN(str), 
// которая преобразует строку в число (аналогично +),
// а затем вернёт true, если это NaN, то есть если преобразование не удалось:
// var x = prompt("Введите значение", "-11.5");
// if (isNaN(x)) {
//   alert( "Строка преобразовалась в NaN. Не число" );
// } else {
//   alert( "Число" );
// }
// Однако, у такой проверки есть две особенности:
// Пустая строка и строка из пробельных символов преобразуются к 0, 
// поэтому считаются числами.
// Если применить такую проверку не к строке, то могут быть сюрпризы,
// в частности isNaN посчитает числами значения false, true, null, так 
// как они хотя и не числа, но преобразуются к ним
// alert( isNaN(null) ); //  выведет:false - не NaN, т.е. "число"
// alert( isNaN("\n  \n") ); //  выведет:false - не NaN, т.е. "число"


// isNumeric(n)
// Если же нужна действительно точная проверка на число, которая не считает
// числом строку из пробелов, логические и специальные значения, а также 
// отсекает Infinity – используйте следующую функцию isNumeric:
// function isNumeric(n) {
//     return !isNaN(parseFloat(n)) && isFinite(n);
// }
// эта функция отсеивается всё, кроме строк-чисел (типа "12") и обычных чисел


// toString()
// Числа можно записывать не только в 10-ричной, но и в 16-ричной системе.
// Но бывает и противоположная задача:  получить 16-ричное представление 
// числа. Для этого используется метод toString(основание системы или 
// система счисления). Основание может быть любым от 2 до 36, например:
// let n = 255;
// alert( n.toString(16) ); // выведет:ff

// Основание 2 бывает полезно для отладки побитовых операций: 
// let n = 4;
// alert( n.toString(2) ); // выведет:100
// Основание 36 (по количеству букв в английском алфавите – 26, вместе с 
// цифрами, которых 10) используется для того, чтобы «кодировать» число в 
// виде буквенно-цифровой строки. В этой системе счисления сначала 
// используются цифры, а затем буквы от a до z:
// let n = 1234567890;
// alert( n.toString(36) ); // выведет: kf12oi
// При помощи такого кодирования можно «укоротить» длинный цифровой 
// идентификатор, например чтобы выдать его в качестве URL


// Округлення
// Одна з самых частих операцій з числом – округлення. В JavaScript 
// існує цілих 3 функціх для цього:
// Math.floor -- Округлення вниз:   alert( Math.floor(3.1) );  // 3
// Math.ceil -- Округлення вверх:   alert( Math.ceil(3.1) );   // 4
// Math.round -- Округляє до найближчого цілого:   
// alert( Math.round(3.2) );  // 3 
// alert( Math.round(4.7) );  // 5

// Округлення бітовими операторами
// Бітові оператори роблять будь-яке число 32-бітним цілим, обрізаючи 
// десятинну частину, alert( ~~12.3 ); // 12
// Будь-яка подібна побітова операція підійде; 
// ось напрклад XOR (виключаюче АБО, "^") з нулем:
// alert( 12.3 ^ 0 ); // 12
// alert( 1.2 + 1.3 ^ 0 ); // виведе: 2, пріоритет ^ меньший, чим +
// Це зручно в першу чергу тим, що легко читается і не заставляє
// ставити додаткові дужки як Math.floor(...):
// let x = a * b / c ^ 0; // читається як "a * b / c та округлити"

// Округлення до заданого знаку:
// Для округлення до потрібного після коми знаку, можна помножити та поділити 
// на 10 з потрібною кількістю нулів. 
// Наприклад, округлимо 3.456 до 2-го знака після коми:
// let n = 3.456;
// alert( Math.round(n * 100) / 100 ); // 3.456 -> 345.6 -> 346 -> 3.46
// Таким чином можна округляти число і вверх і вниз.

// num.toFixed(precision)
// Спеціальний метод num.toFixed(precision)- округляє число num до 
// знаку precision і повертає результат у виді рядка буквенних символів:
// let n = 12.34;
// alert( n.toFixed(1) ); // виведе: "12.3"- рядок буквенних символів (не числових)
// Округлення йде до найближчого значення аналогічно Math.round 
// let n = 12.36;
// alert( n.toFixed(1) ); // виведе: "12.4"
// Отримане значення, при необхідності, доповнюється нулями до потрібної точності:
// let n = 12.34;
// alert( n.toFixed(5) ); // виведе: "12.34000", додані нулі щоб було до 5
// знаків після коми. Якщо потрібно отримати саме число, то можемо
// отримати його, застосувавши '+' до результату n.toFixed(..)
// var n = 12.34;
// alert( +n.toFixed(5) ); // виведе: 12.34

// Метод toFixed не еквівалентний Math.round!
// var price = 6.35;
// alert( price.toFixed(1) ); // виведе: 6.3
// alert( Math.round(price * 10) / 10 ); // выведет: 6.4
// Як видно результат різний! Варіант округлення через Math.round 
// є більш коректний, бо по математичним правилам, значення 5 округлюється
// вверх, а метод toFixed може округлити його як уверх, так и вниз.

// Неточные вычисления
// alert( 0.1 + 0.2 == 0.3 ); // выведет: false - Но тогда что же это?
// alert( 0.1 + 0.2 ); // выведет: 0.30000000000000004
// результат сложения немного больше, чем 0.3 - произошла небольшая 
// вычислительная ошибка. Дело в том, что в стандарте IEEE 754 на число 
// выделяется ровно 8 байт(=64 бита), не больше и не меньше
// Когда мы складываем 0.1 и 0.2, то две неточности складываются, получаем
// незначительную, но всё же ошибку в вычислениях. Eсть два способа сложить
// 0.1 и 0.2: 
// Сделать их целыми, сложить, а потом поделить: 
// alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
// Это работает, так как числа 0.1*10 = 1 и 0.2*10 = 2 могут быть точно 
// представлены в двоичной системе;
// Сложить, а затем округлить до разумного знака после запятой. Округления
// до 10-го знака обычно бывает достаточно, чтобы отсечь ошибку вычислений:
// var result = 0.1 + 0.2;
// alert( +result.toFixed(10) ); // 0.3


// Другие математические методы
// JavaScript предоставляет базовые тригонометрические и некоторые другие 
// функции для работы с числами:

// Тригонометрия. Встроенные функции для тригонометрических вычислений:
// Math.acos(x) - Возвращает арккосинус x (в радианах)
// Math.asin(x) - Возвращает арксинус x (в радианах)
// Math.atan(x) - Возвращает арктангенс x (в радианах)
// Math.atan2(y, x) - Возвращает угол до точки (y, x). Описание функции: Atan2.
// Math.sin(x) - Вычисляет синус x
// Math.cos(x) - Вычисляет косинус x
// Math.tan(x) - Возвращает тангенс x

// Функции общего назначения:
// Math.sqrt(x) - Возвращает квадратный корень из x.
// Math.log(x) - Возвращает натуральный (по основанию e) логарифм x.
// Math.pow(x, exp) - Возводит число в степень, возвращает xexp
// например Math.pow(2,3) = 8. Работает в том числе с дробными и 
// отрицательными степенями, например: Math.pow(4, -1/2) = 0.5.
// Math.abs(x) - Возвращает абсолютное значение числа
// Math.exp(x) - Возвращает ex, где e – основание натуральных логарифмов.
// Math.max(a, b, c...) - Возвращает наибольший из списка аргументов
// Math.min(a, b, c...) - Возвращает наименьший из списка аргументов
// Math.random() - Возвращает псевдослучайное число в интервале 0 - 1 – то 
// есть между 0 (включительно) и 1 (не включая). Генератор случайных чисел
// инициализуется текущим временем.

// Форматирование:
// Для красивого вывода чисел в стандарте ECMA 402 есть метод toLocaleString():
// var number = 123456789;
// alert( number.toLocaleString() ); // 123 456 789
// Его поддерживают все современные браузеры, кроме IE10- (для которых 
// нужно подключить библиотеку Intl.JS).
// Он также умеет форматировать валюту и проценты




//                                      П Р И К Л А Д И


/* Створити сторінку, яка пропонує ввести 2 а числа які потім додати 
 і вивести в консоль. */
// Рішення:
// let a = +prompt("Введіть перше число", ""); // одразу конвертуємо в число
// let b = +prompt("Введіть друге число", ""); // одразу конвертуємо в число
// let sum = a + b;
// console.log( sum );


/* Чому при округленні 6.35.toFixed(1) == 6.3 ми отримуємо такий результат?
адже в математиці прийнято, що 5 округляється вверх, наприклад:
alert( 1.5.toFixed(0) ); // 2
alert( 1.35.toFixed(1) ); // 1.4 */
// Рішення:
// У двійковій системі числення 6.35 є безкінечним дробом. Зберігається
// число із втратою точності:
// alert( 6.35.toFixed(20) ); // 6.34999999999999964473
// Інтерпретатор бачить це число як 6.34..., тому округляє його вниз


/* Представте собі електронний магазин. Ціни дані з точністю до цента
(або євроцента і т.д.). Ви пишете інтерфейс до нього. Основна робота
здійснюється на сервері, але і на точці клієнта все повинно бути добре.
Складання цін за куплений товар і їх множення на його кількість є звичайною
операцією. І власне буде по-дурному виглядати, якщо при замовленні двух 
одиниць товару з цінами 0.10$ и 0.20$ людина отримає загальну вартість 
0.30000000000000004$. Адже як відомо в JS існує втрата точності і 
alert( 0.1 + 0.2 + '$' ); // виведе: '0.30000000000000004$'. Що можна 
зробити для усунення помилки із округлення? */
// Рішення:
// 1) Можна зберігати самі ціни в «центах» (євроцентах і т.д.). Тоді вони 
// завжди будуть цілими і проблеми не буде. Але при показі суми та видачі
// решти від отриманих коштів потрібно це враховувати і ділити результат на
// 100.
// 2) При операціях на програмному рівні, коли потрібно обмінюватись даними
// з сервером – потрібно округляти до 2-го знака пiсля коми, а все що далі
// - помилка:
// let price1 = 0.1, price2 = 0.2;
// alert( +(price1 + price2).toFixed(2) ); // виведе: 0.3 цента (євроцента і т.д.)


/* Цей цикл - безкінечний. Чому?
var i = 0;
while (i != 10) {
  i += 0.2;
} */
// Рішення:
// Тому що і ніколи не буде дорівнювати точно 10. Ось код на підтвердження:
// let i = 0;
// while (i < 11) {
//   i += 0.2;
//   if (i > 9.8 && i < 10.2) alert( i ); 
// код виведе по-черзі: 9.999999999999996 і 10.199999999999996
// }


/* Послідовність Чисел Фібоначі має формулу Fn = Fn-1 + Fn-2.
Тобто, наступне число отримуємо в результаті суми двух попередніх.
Перші два числа рівні 1 (бо перше число після 0 береться 1, а для
наступного числа після 1 обчислення буде 1+0), потім 2 (бо 1+1), далі 
3 (бо 1+2), далі 5 (бо 2+3), далі 8 (бо 3+5) і т. д, тобто послідовність 
для 8 Чисел Фібоначі має вид: 1, 1, 2, 3, 5, 8, 13, 21.
Напишіть код для обчислення послідовності Чисел Фібоначі для заданого 
числа 'n')? 
// Рішення:
// function fib(n) {
//   let a = 1,
//     b = 0,
//     x;
//   for (i = 0; i < n; i++) {
//     x = a + b;
//     a = b;
//     b = x;
//   }
//   return b;
// }
// console.log( fib(8) ); // 21


/* Існує формула Біне, згідно якої Fn дорівнює найближчому цілому 
для ϕn/√5, де ϕ=(1+√5)/2 – золотий зріз. Написати функцію fibBinet(n),
яка буде обчислювати Fn, використовуючи зазначену формулу. Для перевірки
її значення F77 (повинні отримати fibBinet(77) = 5527939700884757).
Чи одинакові результати які отримані за допомогою коду fib(n) і по формулі 
Біне? Якщо ні, то чому і який з них правельний?
*/
// Рішення:
// function fibBinet(n) {
//     let phi = (1 + Math.sqrt(5)) / 2;
//     return Math.round(Math.pow(phi, n) / Math.sqrt(5)); 
//     // тут використовуєм Math.round для округлення до найближчого цілого
//   }
// А тепер використаєм попереднє рішення - функцію для для обчислення 
// послідовності Чисел Фібоначі для порівняння результатів із функцією
// обчислення послідовності по функції Біне:
// alert( fibBinet(2) ); // 1, відповідає і дорівнює fib(2)
// alert( fibBinet(8) ); // 21, відповідає і дорівнює fib(8)
// alert( fibBinet(77) ); // 5527939700884755
// alert( fib(77) ); // 5527939700884757, не відповідає!
// Причина помилкового результату – в похибці і помилці при округленні, 
// адже √5 – безкінечна дріб. А далі, помилки при обчисленні множаться і 
// в результаті дають розбіжність. Обчислення по формулі Біне неточні.


/* Написати код для генерації випадкових значень в діапазоні від 0 до max.
Причому max значення - не включати в діапазон.*/
// Рішення:
// let max = 10; // спочатку згенеруємо значення в діапазоні 0..1 і помножимо його на max
// alert( Math.random() * max ); // видасть наприклад: 8.261091102592088 


/* Написати код для генерації випадкових значень в діапазоні від min до max.
Причому max значення - не включати в діапазон.*/
// Рішення:
// let min = 5, max = 10; // спочатку згенеруємо значення в діапазоні 
// 0..1 додамо до min і помножимо його на різницю (max - min)
// alert( min + Math.random() * (max - min) ); 
// видасть наприклад: 9.237084744222646 


/* Написати функцію randomInteger(min, max) для генерації випадкового 
цілого числа між min і max. Причому значення min і max повинні також 
бути включені у діапазон. Крім того, число з інтервалу min ... max повинно
мати одинакову ймовірність. */
// Рішення:
// Самий простий, але не зовсім вірний спосіб – це згенерувати значення 
// в інтервалі min..max і округлити йго Math.round, ось так:
//  function randomInteger(min, max) {
//   let rand = min + Math.random() * (max - min)
//   rand = Math.round(rand);
//   return rand;
// }
// alert( randomInteger(1, 3) ); // у більшості буде видавати значення 2 
// бо ймовірність отримати крайніх значень min и max буде у два рази меньше,
// ніж 2. Це тому, що Math.round() отримує різні випадкові числа з інтервалу
// від 1 до 3, але при округленні до найближчого цілого буде результат:
// значення з діапазону 1   ... 1.49999..  стануть 1
// значення з діапазону 1.5 ... 2.49999..  стануть 2
// значення з діапазону 2.5 ... 2.99999..  стануть 3
// З цього очевидно що значення 1 (як і 3) ймовірність його випадання у 
// 2 рази менша.
// Правильный спосіб: Math.round(випадкове від min-0.5 до max+0.5). Тобто
// тут діапазон будет той самий (max-min+1), але
// врахована механіка округлення round. Код має вид:
// function randomInteger(min, max) {
//     let rand = min - 0.5 + Math.random() * (max - min + 1)
//     rand = Math.round(rand);
//     return rand;
// }
// alert( randomInteger(5, 10) );

// Альтернативний шлях – застосувати округлення через Math.floor() до 
// випадкового цілого числа від min до max+1
// Наприклад, для генерації цілого числа від 1 до 3, створимо додаткове
// випадкове значення від 1 до 4 (не включаючи 4)
// Тоді Math.floor() округлить їх так:
// 1 ... 1.999+ стане 1
// 2 ... 2.999+ стане 2
// 3 ... 3.999+ стане 3
// Тут ми бачимо усі діапазони одинакові і Код буде мати вид: 
// function randomInteger(min, max) {
//     let rand = min + Math.random() * (max + 1 - min);
//     rand = Math.floor(rand);
//     return rand;
// }
// alert( randomInteger(5, 10) );