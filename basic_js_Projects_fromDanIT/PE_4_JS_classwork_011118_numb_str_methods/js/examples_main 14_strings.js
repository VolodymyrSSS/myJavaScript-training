// тип str
// В JavaScript любые текстовые данные являются строками
// Не существует отдельного типа «символ», который есть в ряде других языков
// Внутренним форматом строк, вне зависимости от кодировки страницы, является Юникод (Unicode)
// Строки создаются при помощи двойных или одинарных кавычек. В Jc нет разницы между двойными и одинарными кавычками
// let text = "моя строка";
// let anotherText = 'еще строка';
// let str = "012345";

// Cпециальные символы
// Строки могут содержать специальные символы. Самый часто используемый из таких символов – это «перевод строки».
// Он обозначается как \n, например:
// alert( 'Привет\nМир' ); // выведет "Мир" на новой строке
// Есть и более редкие Специальные символы, вот их список:
//      Символ	      Описание
      //   \b	        Backspace
      //   \f	        Form feed
      //   \n	        New line
      //   \r	        Carriage return
      //   \t	        Tab
      // \uNNNN	      Символ в кодировке Юникод с шестнадцатеричным кодом `NNNN`. Например, `\u00A9` -- юникодное представление 
//                    символа копирайт ©

// Экранирование
// Если строка в одинарных кавычках, то внутренние одинарные кавычки внутри должны быть экранированы, то есть снабжены 
// обратным слешем \', вот так: let str = 'I\'m a JavaScript programmer';
// В двойных кавычках – экранируются внутренние двойные:
// let str = "I'm a JavaScript \"programmer\" ";
// alert( str ); // I'm a JavaScript "programmer" // выведет: I'm a JavaScript "programmer" 
// В памяти строка будет содержать сам символ без '\'. Сам символ обратного слэша '\' является служебным, 
// поэтому всегда экранируется, т.е пишется как \\ : 
// let str = ' символ \\ ';
// alert( str ); // выведет: символ \
// Заэкранировать можно любой символ. Если он не специальный, то ничего не произойдёт: 
// alert( "\a" ); // выведет: a                   // идентично alert(  "a"  );  // выведет: a


// Здесь мы рассмотрим методы и свойства строк
// Первый символ строки имеет позицию 0

// length
// Длина length - Одно из самых частых действий со строкой – это получение ее длины
// let str = "My\n"; 
// alert( str.length ); // выведет: 3 - 3 символа. Третий - перевод строки

// charAt(позиция)
// Чтобы получить символ, используйте вызов charAt(позиция) - существует по историческим причинам:
// let str = "jQuery";
// alert( str.charAt(0) ); // выведет: j
// Eсли символа нет – charAt выдает пустую строку: alert( "".charAt(0) ); // выведет: пустая строка

// str[позиция]
// Также для доступа к символу можно использовать квадратные скобки – проще и короче:
// let str = "Я - современный браузер!";
// alert( str[0] ); //  выведет: "Я"
// Eсли символа нет – str[позиция] выдает undefined: alert( "" [0] ); // выведет: undefined

// Обратите внимание, str.length – это свойство строки, а str.charAt(pos) – метод, т.е. функция
// Обращение к методу всегда идет со скобками, а к свойству – без скобок

// Изменения строк
// Содержимое строки в JavaScript нельзя изменять. Нельзя взять символ посередине и заменить его. 
// Как только строка создана – она такая навсегда.
// Можно лишь создать целиком новую строку и присвоить в переменную вместо старой, например:
// let str = "строка";
// str = str[3] + str[4] + str[5];
// alert( str ); // ока

// toLowerCase() / toUpperCase()
// Методы toLowerCase() и toUpperCase() меняют регистр строки на нижний/верхний:
// alert( "Интерфейс".toUpperCase() ); // выведет: ИНТЕРФЕЙС
// А здесь только первый символ и приводится к нижнему регистру: alert( "Интерфейс" [0].toLowerCase() ); // выведет: 'и'


// indexOf(подстрока[, начальная_позиция]) 
// Mетод indexOf(подстрока[, начальная_позиция]) возвращает позицию, на которой находится подстрока или -1, если ничего не найдено. Например:
// let str = "Widget with id";
// alert( str.indexOf("Widget") ); // выведет:0, т.к. "Widget" найден прямо в начале str
// alert( str.indexOf("id") ); // выведет:1, т.к. "id" найден, начиная с позиции 1
// alert( str.indexOf("widget") ); // выведет:-1, не найдено, так как поиск учитывает регистр
// Необязательный второй аргумент позволяет искать, начиная с указанной позиции. Например, первый раз "id" появляется на позиции 1.
// Чтобы найти его следующее появление – запустим поиск с позиции 2:
//  let str = "Widget with id";
//  alert(str.indexOf("id", 2)) // выведет: 12, поиск начат с позиции 2

// Также существует аналогичный метод lastIndexOf, который ищет не с начала, а с конца строки

// Для красивого вызова indexOf применяется побитовый оператор НЕ '~'.
// Дело в том, что вызов ~n эквивалентен выражению -(n+1), например: 
// alert( ~2 ); // -(2+1) = -3
// alert( ~1 ); // -(1+1) = -2
// alert( ~0 ); // -(0+1) = -1
// alert( ~-1 ); // -(-1+1) = 0
// kак видно, ~n – ноль только в случае, когда n == -1
// То есть, проверка if ( ~str.indexOf(...) ) означает, что результат indexOf отличен от -1, т.е. совпадение есть.
// Вот так:
// let str = "Widget";
// if (~str.indexOf("get")) {
//   alert( 'совпадение есть!' );
// }
// Вообще, использовать возможности языка неочевидным образом не рекомендуется, поскольку ухудшает читаемость кода.
// Однако, в данном случае, все в порядке. Просто запомните: '~' читается как «не минус один»,
// а "if ~str.indexOf" читается как "если найдено"


// Поиск всех вхождений
// Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле. Как только получаем очередную позицию – 
// начинаем следующий поиск со следующей. Такой цикл начинает поиск с позиции 0, затем найдя подстроку на позиции foundPos, 
// следующий поиск продолжит с позиции pos = foundPos+1, и так далее, пока что-то находит.
// let str = "Ослик Иа-Иа посмотрел на виадук"; // ищем в этой строке
// let target = "Иа"; // цель поиска

// let pos = 0;
// while (true) {
//   let foundPos = str.indexOf(target, pos);
//   if (foundPos == -1) break;

//   alert( foundPos ); // нашли 'Иа' на этой позиции
//   pos = foundPos + 1; // продолжить поиск со следующей
// }

// // тот же алгоритм можно записать и короче:
// let str = "Ослик Иа-Иа посмотрел на виадук"; // ищем в этой строке
// let target = "Иа"; // цель поиска

// let pos = -1;
// while ((pos = str.indexOf(target, pos + 1)) != -1) {
//   alert( pos );
// }
 

// Взятие подстроки
// В JavaScript существуют целых 3 (!) метода для взятия подстроки: substring, substr, slice
// При этом работа substring и slice, присвоение аргументов очень похожи. Различие между substring и slice – в том, 
// как они работают с отрицательными и выходящими за границу строки аргументами. Если выбирать из этих трёх методов один,
// для использования в большинстве ситуаций – то это будет slice: он и отрицательные аргументы поддерживает и работает наиболее очевидно.

// substring(start [, end])
// Метод substring(start, end) возвращает подстроку с позиции start до, но не включая end
// let str = "stringify";
// alert(str.substring(0,1)); // выведет:"s", символы с позиции 0 по 1 не включая 1.
// Если аргумент end отсутствует, то идет до конца строки:
// let str = "stringify";
// alert(str.substring(2)); // выведет:ringify, символы с позиции 2 до конца
// Если есть отрицательные аргументы, то они интерпретируются как равные нулю, а слишком большие значения усекаются до длины строки:
// alert( "testme".substring(-2) ); // выведет:"testme", -2 становится 0
// Кроме того, если start > end, то аргументы меняются местами, т.е. возвращается участок строки между start и end:
// alert( "testme".substring(4, -1) ); // выведет:"test" т.к. -1 становится 0 -> получили substring(4, 0) -> 4 > 0, 
// аргументы меняются местами -> substring(0, 4) - c позиции 0 по 4 не включая 4 = "test"

 
// substr(start [, length])
// Первый аргумент имеет такой же смысл, как и в substring, а второй содержит не конечную позицию, а количество символов.
// let str = "stringify";
// str = str.substr(2,4); // выведет:ring, со 2-й позиции взято 4 символа
// alert(str)
// Если второго аргумента нет – подразумевается «до конца строки»
// Отрицательное значение первого параметра поддерживается в substr во всех браузерах, кроме IE8-


// slice(start [, end])
// Возвращает часть строки от позиции start до, но не включая, позиции end. Смысл параметров – такой же как в substring.
// let str = "marabu";
// alert(str.slice(0,3)); // выведет: mar, символы с позиции 0 по 3 не включая 3.
// Если аргумент end отсутствует, то идет до конца строки:
// let str = "cactus";
// alert(str.slice(1)); // выведет:actus, символы с позиции 1 до конца
// Отрицательные значения в slice отсчитываются от конца строки (это гораздо более удобно, чем странная логика substring):
// alert( "testme".slice(-2) ); // выведет:"me", от 2 позиции с конца
// alert( "testme".slice(1, -1) ); // выведет:"estm", от 1 позиции до первой с конца


// Кодировка Юникод
// Как мы знаем, символы сравниваются в алфавитном порядке 'А' < 'Б' < 'В' < ... < 'Я'.
//Но есть несколько странностей…
// Почему буква 'а' маленькая больше буквы 'Я' большой?   alert( 'а' > 'Я' ); // true
// Буква 'ё' находится в алфавите между е и ж: абвгдеёжз…. Но почему тогда 'ё' больше 'я'?  alert( 'ё' > 'я' ); // true

// Дело в том, что символы сравниваются не по алфавиту, а по коду. У кого код больше – тот и больше
// Строчные буквы идут после заглавных, поэтому они всегда больше. В частности, 'а'(код 1072) > 'Я'(код 1071). 
// То же самое происходит и в английском алфавите, там 'a' > 'Z'
// Ряд букв, например ё, находятся вне основного алфавита. В частности, маленькая буква ё имеет код, больший чем я,
// поэтому 'ё'(код 1105) > 'я'(код 1103). Кстати, большая буква Ё располагается в Unicode до А, поэтому 'Ё'(код 1025) < 'А'(код 1040).
//  Удивительно: есть буква меньше чем А :). Буква ё не уникальна, точки над буквой используются и в других языках, приводя к тому же
// результату. Например, при работе с немецкими названиями: alert( "ö" > "z" ); // true


// Все строки в JavaScript имеют внутреннюю кодировку Юникод. Неважно, на каком языке написана страница, 
// находится ли она в windows-1251 или utf-8. Внутри JavaScript-интерпретатора все строки 
// приводятся к единому «юникодному» виду. В юникоде есть много разных символов. Кириллическим буквам соответствует
// только небольшая часть из них. Каждому символу соответствует свой код

// String.fromCharCode(code)
// String.fromCharCode(code) - Возвращает символ по его коду code: alert( String.fromCharCode(1072) ); // 'а'
// Выведем отрезок символов юникода с кодами от 1034 до 1113:
// let str = '';
// for (let i = 1034; i <= 1113; i++) {
//   str += String.fromCharCode(i);
// }
// alert( str ); // выведет: ЊЋЌЍЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюяѐёђѓєѕіїјљ

// str.charCodeAt(pos)
// Mетод str.charCodeAt(pos) - для получения цифрового кода из символа: alert( "абрикос".charCodeAt(0) ); // 1072, код 'а'
// Возвращает код символа на позиции pos. Отсчет позиции начинается с нуля.

//Посимвольное сравнение
// Сравнение строк работает лексикографически, иначе говоря, посимвольно. Сравнение строк s1 и s2 обрабатывается по следующему алгоритму:
// Сравниваются первые символы: s1[0] и s2[0]. Если они разные, то сравниваем их и, в зависимости от результата их сравнения, 
// возвратить true или false. Если же они одинаковые, то… Сравниваются вторые символы s1[1] и s2[1] Затем третьи s1[2] и s2[2] и так далее,
// пока символы не будут наконец разными, и тогда какой символ больше – та строка и больше. Если же в какой-либо строке закончились символы,
// то считаем, что она меньше, а если закончились в обеих – они равны.
// Спецификация языка определяет этот алгоритм более детально. Если же говорить простыми словами, смысл алгоритма в точности соответствует
// порядку, по которому имена заносятся в орфографический словарь.
// "Вася" > "Ваня" // true, т.к. начальные символы совпадают, а потом 'с' > 'н'
// "Дома" > "До" // true, т.к. начало совпадает, но в 1-й строке больше символов


// Числа в виде строк сравниваются как строки
// Бывает, что числа приходят в скрипт в виде строк, например как результат prompt. В этом случае результат их сравнения будет неверным:
// alert( "2" > "14" ); // true, так как это строки, и для первых символов верно "2" > "1"
// Если хотя бы один аргумент – не строка, то другой будет преобразован к числу:  alert( 2 > "14" ); // false

// str1.localeCompare(str2)
// Метод str1.localeCompare(str2) возвращает -1, если str1 < str2,
// Метод str1.localeCompare(str2) возвращает 1, если str1 > str2,
// Метод str1.localeCompare(str2) возвращает 0, если str1 == str2









//                                      П Р И К Л А Д И



/* Написати функцію ucFirst(str), яка повертає рядок str, який має великий перший символ, наприклад:
ucFirst("василь") == "Василь";
ucFirst("") == ""; // немає помилок у разі пустого рядка
P.S. В JavaScript немає готового методу для цього
Треба створити функцію, використовуючи toUpperCase() і charAt() */ 

// Рішення:
// Ми не можемо замінити перший символ бо рядки в JavaScript незмінні. Але можна по-новому створити рядок на основі 
// вже існуючого рядка і з великим першим символом: 
// let newStr = str[0].toUpperCase() + str.slice(1);
// Проте у такому варіанті та коли рядок пустий - буде помилка бо str[0] == undefined, а у undefined немає методу toUpperCase()
// Тоді, можливим рішенням може бути використання str.charAt(0), який завжди повертає рядок, для пустого рядка – пустий символ, але не undefined
// Іншим способом можна вирішити - спеціально перевірити на пустий рядок
// function ucFirst(str) {
//   // тільки пустий рядок в логічному контексті дасть false
//   if (!str) return str;
//   return str[0].toUpperCase() + str.slice(1);
// }
// alert( ucFirst("василь") );




/* Написати функцію checkSpam(str), яка повертає true, якщо рядок str містить слово „viagra“ чи „XXX“, а якщо ні то вивести false.
Функція повинна бути нечутлива до регістру:
checkSpam('buy ViAgRA now') == true
checkSpam('free xxxxx') == true
checkSpam("innocent rabbit") == false */

// Рішення:
// Метод indexOf шукає співпадіння із урахуванням регістру. Тобто у рядку 'xXx' він не знайде 'XXX'.
// Отже, для провірки, спочатку потрібно рядок str перевести до нижнього регістру і далі здійснювати пошук
// function checkSpam(str) {
//   let lowerStr = str.toLowerCase();
//   if (!!(~lowerStr.indexOf('viagra') || ~lowerStr.indexOf('xxx'))) {
//     return true;
//   } else {
//     return false
//   }
// }
// alert( checkSpam('buy ViAgRA now') );  // виведе: true
// alert( checkSpam('free xxxxx') );      // виведе: true
// alert( checkSpam("innocent rabbit") ); // виведе: false




/* Створити функцію truncate(str, maxlength), яка перевіряє довжину рядка str, і якщо вона більша від maxlength
– заміняє кінець рядка str на "...", таким чином, щоб довжина рядка стала рівною заданій maxlength.
Результат функції повинен бути (при необхідності) обрізаний рядок заданої довжини.
Наприклад: 
truncate("Ось, що мені хотілось би сказати на цю тему:", 25) = "Ось, що мені хотілось ..."
truncate("Усім привіт!", 20) = "Усім привіт!"
Ця функція має застосування в житті. Она використовується щоб обрізати дуже довгі рядки повідомлень */

// Рішення:
// Через те, що кінцева довжина рядка повинна відповідати значенню maxlength, то потрібно врахувати це і її обрізати трохи коротше,
// щоби дати місце для трьох крапок.
// function truncate(str, maxlength) {
//   if (str.length > maxlength) {
//     return str.slice(0, maxlength - 3) + '...';
//   } else {                                              // загальна довжина дорівнює чи менша заданому значенню maxlength
//      return str;
// }
// alert( truncate("Ось, що мені хотілось би сказати на цю тему:", 25) );
// alert( truncate("Усім привіт!", 20) );

// Можна цей код написати ще коротше:
// function truncate(str, maxlength) {
//   return (str.length > maxlength) ?
//     str.slice(0, maxlength - 3) + '...' : str;
// }




/* Є вартість зазначена у вигляді рядка: "$120". Тобто у вартості першим йде знак валюти а потім – число.
Потрібно створити функцію extractCurrencyValue(str), яка буде з такого рядка виділяти числове - значення, в даному випадку 120 */

// Рішення:
// let str = "$120";
// function extractCurrencyValue(str) {
//   return +str.slice(1);
// }
// extractCurrencyValue(str);
// let onlyNumValue = extractCurrencyValue(str);
// alert ( onlyNumValue );