// Специально для работы с рекурсией в JavaScript существует особое расширение функциональных выражений, 
// которое называется «Named Function Expression» (сокращённо NFE) или, по-русски, «именованное функциональное выражение»


// Обычное функциональное выражение имеет вид: var f = function(...) { /* тело функции */ };

// Именованное с именем sayHi: var f = function sayHi(...) { /* тело функции */ };
// Это имя доступно только изнутри самой функции (f). Это ограничение видимости входит в стандарт JS
// и поддерживается всеми браузерами (кроме IE8)

// Например:
// let f = function sayHi(name) {
//   alert( sayHi );                  // изнутри функции - видно (выведет написаный код функции)
// };
// alert( sayHi );                    // снаружи - не видно (ошибка: undefined variable 'sayHi')

// Кроме того, имя NFE нельзя перезаписать, Например:
// var test = function sayHi(name) {
//   sayHi = "тест";                // попытка перезаписи
//   alert( sayHi );                // выдаст Error: Assignment to constant variable (перезапись не удалась)
// };
// test();                          // запуск функции для её выполнения


// Имя NFE используется для единственной цели – позволить изнутри функции вызвать саму себя 
// Это имя предназначено для надёжного рекурсивного вызова функции, даже если она записана в другую переменную.
// NFE используется в первую очередь в тех ситуациях, когда функцию нужно передавать в другое
// место кода или перемещать из одной переменной в другую
// внутреннее имя позволяет функции надёжно обращаться к самой себе, где бы она ни находилась

// Вспомним, к примеру, функцию-факториал:
// function f(n) {
//     return n ? n * f(n - 1) : 1;
// };
// alert( f(5) );                // 120
// Попробуем перенести её в другую переменную g:
// function f(n) {
//     return n ? n * f(n - 1) : 1;
// };
// let g = f;
// f = null;                                              // Ошибка возникла потому что функция из своего кода обращается к своему 
// alert( g(5) ); // Error: f is not a function!          // старому имени f. А этой функции уже нет, f = null. 

// Для того, чтобы функция всегда надёжно работала, объявим её как Named Function Expression:
// let f = function factorial(n) {
//     return n ? n*factorial(n-1) : 1;
//   };
  
// let g = f;                                               // скопировали ссылку на функцию-факториал в g
// f = null;
// alert( g(5) );                                           // 120, работает!





//                                                 П Р И К Л А Д И




/* Який буде результат виконання коду? */ 

// // Рішення:
// function g() { return 1; }
// alert(g);                           // виведе: function g() { return 1; } - функція всередині є звичайною FuncDecl і її ім`я видно,
//                                     // а тому спрацює, причому виведе увесь код бо g - без дужок; якщо alert(g()); - виведе: 1
 



// Який буде результат виконання цього коду?

// // Рішення:
// (function g() { return 1; });
// alert(g);                          // виведе: undefined variable - через те, що функція взята в дужки - тобто є частиною виразу і належить
//                                    // до Named Function Expression, яке видно тільки з середини тому її виклик виведе помилку бо дужки 
//                                    // закрили ім'я функції, яке видно тільки з середини а ми викликаємо її з-зовні - тому її не видно





/* Написати функцію виведення даних на товари "ноутбуки: Lenovo та Samsung"
Серед даних на товар створити другу функцію яка буде отримувати повне ім'я на товар
Вивести в консолі усі дані на товар, потім повне ім'я на товар.
Далі вивести окремо ціни на товар після скидки */

// // Рішення:
function getGoods(name, price, id) {
    this.goodName = name;
    this.goodPrice = price;
    this.goodId = id; 
    this.getFullName = function () {
       fullName = this.goodName + " " + this.goodId;
       return fullName;
    }
};
let lenovo = new getGoods("Lenovo S120", 15000, "ES12456");
console.log(lenovo);                       // виведе: getGoods {goodName: "Lenovo S120", goodPrice: 15000, goodId: "ES12456", getFullName: ƒ}
console.log(lenovo.getFullName());         // виведе: Lenovo S120 ES12456
let samsung = new getGoods("Samsung N34", 25000, "EF12458");
console.log(samsung);                      // виведе: getGoods {goodName: "Samsung N34", goodPrice: 25000, goodId: "EF12458", getFullName: ƒ}
console.log(samsung.getFullName());        // виведе: Samsung N34 EF12458
lenovo.price = 12000;
samsung.price = 23000;
console.log("Після скидки вартість 'Lenovo S120' буде  " + lenovo.price); // виведе: Після скидки вартість 'Lenovo S120' буде  12000
console.log("Після скидки вартість 'Samsung N34' буде " + samsung.price); // виведе: Після скидки вартість 'Samsung N34' буде 23000