// Очень часто нам надо повторять одно и то же действие во многих частях программы
// Примеры встроенных функций уже известны – это alert(message), prompt(message, default) и confirm(question)
// Главная цель создания функций: избавление от дублирования кода. 
// Функции являются основными «строительными блоками» программы поэтому мы будем создавать свои функции
 
//Классическое» объявление функции в спецификации языка называется «Function Declaration» - функция, объявленная в основном потоке кода и имеет вид:
// function имя(параметры) {                   // ключевое слово function, после него имя функции, затем список параметров в скобках
//   ...                                       // тело функции – код, который выполняется при её вызове
// }
// Например:
// function showMessage() {                       // ключевое слово function, после него имя функции showMessage, затем список параметров в скобках
//   alert( 'Привет всем присутствующим!' ); // в теле функции – вывесити (alert) выражение (Привет всем присутствующим!) 
// }

//Объявленная функция доступна по имени
// function showMessage() {
//     alert( 'Привет всем присутствующим!' );
// }
// showMessage();                                 // выведет сообщение 'Привет всем присутствующим!' первый раз 
// showMessage()                                  // выведет сообщение 'Привет всем присутствующим!' второй раз

// Функция может содержать локальные переменные, объявленные через var. Такие переменные видны только внутри функции:
// function showMessage() {
//     var message = 'Привет, я - Вася!'; // локальная переменная
//     alert( message );
// }
// showMessage(); // 'Привет, я - Вася!'
// alert( message ); // будет ошибка, т.к. переменная видна только внутри

// Блоки if/else, switch, for, while, do..while не влияют на область видимости переменных
// function count() {
//     // переменные i,j не будут уничтожены по окончании цикла
//     for (var i = 0; i < 3; i++) {
//       var j = i * 2;
//     }
//     alert( i ); // i=3, последнее значение i, при нём цикл перестал работать
//     alert( j ); // j=4, последнее значение j, которое вычислил цикл
// }
// Неважно, где именно в функции и сколько раз объявляется переменная. 
// Любое объявление срабатывает один раз и распространяется на всю функцию

// Функция может обратиться ко внешней переменной
// var userName = 'Вася';
// function showMessage() {
//   var message = 'Привет, я ' + userName;
//   alert(message);
// }
// showMessage(); // Привет, я Вася

// Доступ возможен не только на чтение, но и на запись. При этом, так как переменная внешняя, то изменения будут видны и снаружи функции
// var userName = 'Вася';
// function showMessage() {
//   userName = 'Петя'; // присвоение значения также во внешнюю переменную
//   var message = 'Привет, я ' + userName;
//   alert( message );
// }
// showMessage();
// alert( userName ); // Петя, значение внешней переменной изменено функцией
// Конечно, если бы внутри функции, в строке (49), была бы объявлена своя локальная переменная var userName,
// то все обращения использовали бы её, и внешняя переменная осталась бы неизменной

// Переменные, объявленные на уровне всего скрипта, называют «глобальными переменными»
// В примере выше переменная userName – глобальная
// Делайте глобальными только те переменные, которые действительно имеют общее значение для вашего проекта, 
// а нужные для решения конкретной задачи – пусть будут локальными в соответствующей функции

// В старом стандарте JavaScript существовала возможность неявного объявления переменных присвоением значения
// function showMessage() {
//     message = 'Привет'; // без var! переменная message нигде не объявлена, а сразу присваивается - переменная создана автоматически
// }                       // Избегайте этого !!!
// showMessage();
//   alert( message );     // Привет - выведется только в старом JavaScript, при use strict такой код привёл бы к ошибке !
// Здесь опасность даже не в автоматическом создании переменной. Забыли var в одном месте, потом в другом – в результате
// одна функция неожиданно поменяла глобальную переменную, которую использует другая - найти ошибку очень тяжело! Избегайте этого !!!

// При вызове функции ей можно передать данные, которые та использует по своему усмотрению
// function showMessage(from, text) {                    // тут заданы параметры: from и text
//     from = "** " + from + " **";                      // здесь может быть сложный код оформления
//     alert(from + ': ' + text);
// }
// showMessage('Маша', 'Привет!');                       // выведет: ** Маша **: Привет!
// showMessage('Маша', 'Как дела?');                     // выведет: ** Маша **: Как дела?

// Параметры копируются в локальные переменные функции
// function showMessage(from, text) {
//     from = '**' + from + '**';                         // при запуске функции внешняя переменная from копируется в параметр функции с тем же именем
//     alert( from + ': ' + text );                       // выведет: ** Маша **: Привет!
// }
// var from = "Маша";                                     // обявлен внешняя переменная from
// showMessage(from, "Привет");
//   alert( from );                                       // старое значение from без изменений, выведет: Маша

// Функцию можно вызвать с любым количеством аргументов
// Если параметр не передан при вызове – он считается равным undefined
// Например, функцию показа сообщения showMessage(from, text) можно вызвать с одним аргументом: showMessage("Маша");
// Eсли параметр не передан – присвоить ему значение «по умолчанию»
// function showMessage(from, text) {
//     if (text === undefined) {
//       text = 'текст не передан';
//     }
  
//     alert( from + ": " + text );
// }
// showMessage("Маша", "Привет!");                      // выведет: Маша: Привет!
// showMessage("Маша");                                 // выведет: Маша: текст не передан

// Для указания значения «по умолчанию», то есть, такого, которое используется, если аргумент не указан, используется два способа:
// Можно проверить, равен ли аргумент undefined, и если да – то записать в него значение по умолчанию (в примере выше).
// Использовать оператор ||
// function showMessage(from, text) {
//     text = text || 'текст не передан';
//     ...
// }

// Функция может возвратить результат. Для возврата значения используется директива return
// Она может находиться в любом месте функции. Как только до неё доходит управление – функция завершается и значение передается обратно
// function calcD(a, b, c) {
//     return b*b - 4*a*c;
// }
// var test = calcD(-4, 2, 1);
//  alert(test);                         // выведет: 20

// Вызовов return может быть и несколько
// function checkAge(age) {
//     if (age > 18) {
//       return true;
//     } else {
//       return confirm('Родители разрешили?');
//     }
// }
// var age = prompt('Ваш возраст?');
//   if (checkAge(age)) {
//     alert( 'Доступ разрешен' );
//   } else {
//     alert( 'В доступе отказано' );
//   }

//  Директива return может также использоваться без значения, чтобы прекратить выполнение и выйти из функции
// function showMovie(age) {
//     if (!checkAge(age)) {
//       return;
//     }
//     alert( "Фильм не для всех" );        // если сработал if, то эта строка и весь код под ней никогда не выполнится, 
//     // ...                               // так как return завершает выполнение функции
// }

// В случае, когда функция не вернула значение или return был без аргументов, считается что она вернула undefined
// пример без return
// function doNothing() { /* пусто */ }
//     alert( doNothing() );                  // никакой ошибки нет. Просто возвращается undefined

// //или пример с return без аргумента
// function doNothing() {
//     return;
// }
//   alert( doNothing() === undefined );     // true

// Выбор имени функции должно быть глаголом, т.к. функция – это действие.
// Это очень удобно, поскольку взглянув на функцию – мы уже примерно представляем, что она делает
// Функция должна делать только то, что явно подразумевается её названием. И это должно быть одно действие

// Если действие функции сложное и подразумевает поддействия – может быть имеет смысл выделить их в отдельные функции
// Поддействия – может быть имеет смысл выделить их в отдельные функции? Зачастую это имеет смысл, чтобы лучше структурировать код
// Например, функция проверки данных (скажем, "validate") не должна показывать сообщение об ошибке. Её действие – проверить

// Функции, которые начинаются с "show" – что-то показывают: showMessage(..)  -  префикс show, "показать" сообщение
// Функции, начинающиеся с "get" – получают - что-то получают: getAge(..) - префикс get, "получает" возраст
// Функции, начинающиеся с  "calc" - вычисляет, подсчитывает что-то: calcD(..) - префикс calc, "вычисляет" дискриминант
// Функции, начинающиеся с  "chec" - проверяет что-то: checkPermission(..) -  префикс check, "проверяет" разрешение, возвращает true/false                                                               createForm(..) - create, "создает" форму
// Функции, начинающиеся с  "create" - создает что-то: createForm(..) - префикс create, "создает" форму
// Имена функций, которые используются очень часто, иногда делают сверхкороткими.

// Например, во фреймворке jQuery есть функция $, во фреймворке Prototype – функция $$, 
// а в библиотеке LoDash очень активно используется функция с названием из одного символа подчеркивания _







//                                               П Р И К Л А Д И




/*Написати функцію, яка буде виводити ім'я та фамілію студента з переліку даних, які включають:
Cидоренко Василь Іванович, має 18 років, народився у Львові, навчається на 2 курсі Києво-Могилянської Академії,
Він має якийсь середній бал з дисциплін навчання. */

// Рішення:
// let name = "Василь";
// let lastName = "Сидоренко";
// let patronimicName = "Іванович";
// let yearStudy = 2;
// let age = 18;
// let bornPlace = "Lviv";
// let stadyInstalation = "KMA - Kyiv-Mochylyan Academy";
// let avarageScore;

// function getLastName() {
//     alert( name + " " + lastName + " - ім'я та фамілія студента" );
// }
// getLastName(); // зробить те, що описано всередині функції





/*Написати функцію, яка конвертує градуси по Фаренгейту в градуси по Цельсію.
Спочатку запитати ввести градуси по Фаренгейту, виконати функцію та повернути
конвертоване значення по Цельсію */

// Рішення:
// let f = (+ prompt ("Введіть значення по Фаренгейту", 77) );
// function toCelsius(f) {
//     return (5/9) * (f-32);
// }
// toCelsius(f);
// alert ( toCelsius(f) );





/*Функція, яка представлена нижче повертає true, якщо параметр age більше 18. В іншому разі вона задає питання 
за допомогою виклику confirm і повертає його результат */
// let age = ( prompt("Введіть ваш вік", 10) );
// function checkAge(age) {
//     if (age > 18) {
//       return alert ( "Ви маєте доступ");
//     } else {
//       // ...
//       return confirm('А батьки дозволили ?');
//     }
// }
// checkAge(age)
// запитання: Чи буде працювати ця функція якось по інакшому, якщо забрати else ?
// function checkAge(age) {
//     if (age > 18) {
//       return alert ( "Ви маєте доступ");
//     }
//     // ...
//     return confirm("А батьки дозволили ?");
// }
// Рішення: ні не буде працювати поіншому. Обидва варіанти працюють одинаково




/*Функція, яка представлена нижче повертає true, якщо параметр age більше 18. В іншому разі вона задає питання 
за допомогою виклику confirm і повертає його результат */
// function checkAge(age) {
//     if (age > 18) {
//       return true;
//     } else {
//       return confirm("А батьки дозволили ?");
//     }
// }
// Завдання: переписати функцию щоб вона робила те саме, але без if, в один рядок. 
// Зробити два варіанта функції checkAge: використовуючи оператор '?' та використовуючи оператор ||

// Рішення:
// варіант 1 з оператором "?": 
// function checkAge(age) {
//     return (age > 18)? true: confirm("А батьки дозволили ?");
// }

// варіант 2 з оператором "||":
// function checkAge(age) {
//     return (age > 18)? || confirm("А батьки дозволили ?");
// }




/*Написати функцію min(a,b), яка повертає меньше з двох чисел чисел a,b.
Для перевірки результату: min(2, 5) == 2  min(3, -1) == -1    min(1, 1) == 1 */

// let a = ( +prompt("Введіть перше число", 0) );
// let b = ( +prompt("Введіть друге число", 0) );
// function min(a,b) {
//     if (a > b) {
//         return b;
//     }
//     else return a
// }
// min(a,b);          
// alert ( min (a,b) );         // тут функція викликається алертом 2й раз через модальне вікно, щоб вивести результат
// let minNumber = min(a,b);    // а, тут - свого роду, результат роботи функції присвоюється перемінній і він же і 
// alert( minNumber );          // виводиться (а не знову функція викликається повторно)




/*Написати функцію pow(x,n), яка повертає x в степені n. 
Іншими словами множить х на себе n разів і повертає результат. У цій задачі функція повинна 
підтримувати тільки натуральні значення степені n - тобто цілі від 1 і вище.
Для перевірки результату: pow(3, 2) = 3 * 3 = 9,  pow(3, 3) = 3 * 3 * 3 = 27,
pow(1, 100) = 1 * 1 * ...*1 = 1 */

// Рішення:
// function pow(x, n) {
//   let result = x;                           // задаєм змінній Х якийсь попередній результат
//   for (let i = 1; i < n; i++) {             // порядок переходу на крок для множення змінної х на саму себе
//     result *= x;                            // множeння змінної х на саму себе
//   }                                          
//   return result;                            // виводимо змінну Х із обрахованим результатом
// }

// let x = ( +prompt("Введіть число, яке хочете поставити у степінь", 0) );
// let n = ( +prompt("Зазначте степінь", 2) );
//   if (n <= 1) {
//     alert ("Степінь " + n + " повинна бути більше 1");
//   } else {
//       alert ( pow(x, n) );
// }




/* Написати функцію sumTo(n), яка для взятого n вираховує суму чисел від 1 до n (арифметична прогресія), наприклад:
sumTo(1) = 1
sumTo(2) = 2 + 1 = 3
sumTo(3) = 3 + 2 + 1 = 6
sumTo(4) = 4 + 3 + 2 + 1 = 10
...
sumTo(100) = 100 + 99 + ... + 2 + 1 = 5050 

Результатом роботи функції повинно бути таке:
function sumTo(n) { ... написаний код ...  }
alert( sumTo(100) ); // 5050
Рішения зробити у 2 варіантах: з циклом та по формулі для суми арифметичної прогресії */ 

// Рішення за допомогою циклу:
// function sumTo(n) {                              // даємо назву функції
//     let sum = 0;                                 // визначаємо початкове/попереднє значення сумми
//     for (let i = 1; i <= n; i++) {               // задаємо змінну і, яка буде визначати крок додавання 
//         sum = sum + i;                           // додаємо до початкового/попереднього значення крок додавання
//     }                                           
//     return sum;                                  // виводимо результат обрахувань
// }
// let n = +prompt("Введіть ціле число", "1");
// alert( sumTo(n) );

// Рішення з використанням формули для суми арифметичної прогресії:
// по формулi: sumTo(n) = n*(n+1)/2:
// function sumTo(n) {
//     return n * ( n + 1 ) / 2;
// }
// let n = +prompt("Введіть ціле число", "1");
// alert( sumTo(n) );




/* Написати функцію factorial(n), яка повертає факторіал числа n!, наприклад:
alert( factorial(5) ); // 120
Приклади значень для різних факторіалів:
0! = 1   // так домовились і прийняли
1! = 1
2! = 2 * 1 = 2
3! = 3 * 2 * 1 = 6
4! = 4 * 3 * 2 * 1 = 24
5! = 5 * 4 * 3 * 2 * 1 = 120
...
Факторіал числа - це результат множення одне на одного усіх чисел які стоять від цього числа до 1. Позначается n!
Можна сказати по іншому, – це число, помножене на «себе мінус один», потім на «себе мінус два» и т. д., до одиниці. 
Можна факторіал записати загальною формулою: n! = n * (n - 1) * (n - 2) * ...*1
//                                           4! = 4 * (4 - 1) * (4 - 2) * (4 - 3) = 24

Необхідно зробити вариантами рішения із використанням циклів for та while, причому while із інкрементом та декрементом окремо;
*/

// Рішення за допомогою циклу for:
// function factorial(n) {

//     let res = 1;
//     for (let i = 1; i <= n; i++) {
//         res = res * i;
//     }
//     return res; 
// }
// let n = +prompt("Введіть ціле число", "1");
// alert( factorial(n) );

// Рішення за допомогою циклу while та інкременту:
// function factorial(n) {
    
//     let res = 1;
//     while (i <= n) {
//         res *= i;
//         i++
//     }
//     return res; 
// }
// let n = +prompt("Введіть ціле число", "1");
// alert( factorial(n) );

// Рішення за допомогою циклу while та декременту:
// function factorial(n) {
    
//     let res = 1;
//     let i = n;
//     while (i) {
//         res *= i;
//         i--
//     }
//     return res; 
// }
// let n = +prompt("Введіть ціле число", "1");
// alert( factorial(n) );



/* Написати функцію fib(n), яка повертає n-е число Фiбоначi, наприклад:
function fib(n) { ... створений код... }
alert( fib(3) ); // 2
alert( fib(7) ); // 13
alert( fib(77)); // 5527939700884757
Числа Фiбоначi тiсно повязане з золотим зрізом і багатьма природніми явищами навколо нас
Будь-яке число з послідовності чисел Фібоначчі отримуєтьсяся у результаті суми двух попередніх і будується по правилy:
n0 = -n2 + -n1; n1 = -1n + n0; n2 = n0 + n1; n3 = n1 + n3. Послiдовнiсть чисел Фiбоначi має формулу Fn = Fn-1 + Fn-2.
Перші два числа рівні 1, потім 2(1+1), далі 3(1+2), 5(2+3) и так длі: 1, 1, 2, 3, 5, 8, 13, 21, 34, ....
Тобто слідуюче число отримуємо в результаті суми двух попередніх:
//     let a = 1;           =  1                                    let a = b;           =  5
//     let b = 1;           =  1        n = 2                       let a = b;           =  8       n = 6
//     let c = a + b;       =  2                                    let с = а + b;       =  13

//     let a = b;           =  1                                    let a = b;           =  8
//     let b = c;           =  2        n = 3                       let b = c;           =  13      n = 7
//     let c = a + b;       =  3                                    let c = a + b;       =  21

//     let a = b;           =  2                                    let a = b;           =  13
//     let b = c;           =  3        n = 4                       let b = c;           =  21      n = 8
//     let c = a + b;       =  5                                    let c = a + b;       =  34
    
//     let a = b;           =  3                                        ...
//     let b = c;           =  5        n = 5
//     let c = a + b;       =  8

Задачу необхідно зробити вариантами рішения:
- з використанням циклу for;
- через рекурсію, наприклад:
 */

// Рішення через цикл for:  
//  function fib(n) {

//   let a = 1, b = 1;
//     for (i = 3; i <= n; i++) {  //  перше і друге (a i b) числа вже визначенні як змінні, а тому починаємо з 3го числа
//       let c = a + b;
//       a = b, b = c;
//   } return b;
 
// }
// let n = +prompt("Введіть будь-яке ціле число", "1");
// alert( fib(n) );


// Рішення через цикл for щоб включити у діапазон відємні значення:
// function fib(n) {
//   let a = 1, b = 1;
//   if (n > 0) {
//     for (i = 3; i <= n; i++) {  //  перше і друге (a i b) числа вже визначенні як змінні, а тому починаємо з 3го числа
//       let c = a + b;
//       a = b;
//       b = c;
//     } 
//     return b;
//   }
//   else {
//     let a = -1, b = -1;
//     for (i = -3; i >= n; i--) {  //  перше і друге (-a i -b) числа вже визначенні як змінні, а тому починаємо з -3го числа
//       let c = a + b;
//       a = b;
//       b = c;
//     } 
//     return b;
//   }
// }
// let n = +prompt("Введіть будь-яке ціле число", "1");
// alert( fib(n) );