// В теле функции могут быть вызваны другие функции для выполнения подзадач
// Частный случай подвызова – когда функция вызывает сама себя. Это называется рекурсией
// Рекурсия используется для ситуаций, когда выполнение одной сложной задачи можно представить как 
// некое действие в совокупности с решением той же задачи в более простом вариантe

// В качестве первого примера использования рекурсивных вызовов – рассмотрим задачу возведения числа x в натуральную степень n
// Её можно представить как совокупность более простого действия и более простой задачи того же типа вот так:
//  x в степ n = x * x в степ n-1 - > pow(x, n) = x * pow(x, n - 1)

// Например, вычислим pow(2, 4), последовательно переходя к более простой задаче:
// pow(2, 4) = 2 * pow (2, 3) 
// pow(2, 3) = 2 * pow (2, 2)
// pow(2, 2) = 2 * pow (2, 1)
// pow(2, 1) = 2                      // Далее, имея результат на шаге 4, он подставляется обратно в шаг 3, 
//                                    // затем имеем pow(2,2) – подставляем в шаг 2 и на шаге 1 уже получаем результат
// Код для этой задачи в JS:

// function pow(x, n) {
//     if (n != 1) {                  // пока n != 1, сводить вычисление pow(x,n) к pow(x, n-1)
//       return x * pow(x, n - 1);
//     } else {
//       return x;
//     }
// }
// alert( pow(2, 3) ); // выведет: 8

// Говорят, что «функция pow рекурсивно вызывает сама себя» до n == 1.
// Значение, на котором рекурсия заканчивается, называют базисом рекурсии. В примере выше базисом является 1.
// Общее количество вложенных вызовов называют глубиной рекурсии. В случае со степенью, всего будет n вызовов.
// Максимальная глубина рекурсии в браузерах ограничена, точно можно рассчитывать на 10000 вложенных вызовов, 
// но некоторые интерпретаторы допускают и больше.
// Итак, рекурсию используют, когда вычисление функции можно свести к её более простому вызову, а его – ещё к 
// более простому, и так далее, пока значение не станет очевидно.
// Рекурсия очень прожорлива к ресурсам компа.


// У каждого вызова функции есть свой «контекст выполнения» (execution context)  – это служебная информация, 
// которая соответствует текущему запуску функции. Она включает в себя локальные переменные функции и конкретное
// место в коде, на котором находится интерпретатор.
// При любом вложенном вызове JS запоминает текущий контекст выполнения в специальной внутренней структуре данных – «стеке контекстов»
// Затем интерпретатор приступает к выполнению вложенного вызова
// Для нового вызова создаётся свой контекст выполнения, и управление переходит в него, а когда он завершён – старый 
// контекст достаётся из стека и выполнение внешней функции возобновляетсa

// Реализация возведения в степень через цикл гораздо более экономна:
// function pow(x, n) {
//     var result = x;
//     for (var i = 1; i < n; i++) {
//       result *= x;
//     }
//     return result;
// }                      // У такой функции pow будет один контекст, в котором будут последовательно меняться значения i и result
// Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее
// Но переделка рекурсии в цикл может быть нетривиальной, особенно когда в функции, в зависимости от условий, используются различные
// рекурсивные подвызовы, когда ветвление более сложное





//                                                 П Р И К Л А Д И




/* Написати функцію sumTo(n) за допомогою рекурсії, яка для взятого n вираховує суму чисел від 1 до n (арифметична прогресія), наприклад:
sumTo(1) = 1
sumTo(2) = 2 + 1 = 3
sumTo(3) = 3 + 2 + 1 = 6
sumTo(4) = 4 + 3 + 2 + 1 = 10
...
sumTo(100) = 100 + 99 + ... + 2 + 1 = 5050 

Також, чи можна при допомозі рекурсії порахувати sumTo(100000)? Якщо ні то чому? 
Крім того, який з варіантів (дивлячись на варіанти рішення через цикл та по формулі арифм прогресії)
є самий швидкий, а який є самий повільний? І чому?
*/ 

// Рішения: тут цю функцію можна представити як sumTo(n) = n + sumTo(n-1) для n > 1; тому 
// function sumTo(n) {
//     if (n > 1) {
//         return n + sumTo(n-1);
//     } else {
//         return 1;
//     }
// }
// let n = +prompt("Введіть ціле число", "1");
// alert( sumTo(n) );

// Існує обмеження глибини вложених викликів, тому рекурсивный виклик sumTo(100000) в деяких браузерах видає помилку
// Самий швидкий варіант із 3-х варіантів рішення задачі є рішення з використання арифметичної прогресії. Це є тому,
// що рішення здійснюється всього за 3 операції для любого n. А через цикли і рекурсію потрібно як мінімум n операцій додавання
// Варіант з циклом - другий по швидкості бо кількість додавань одинакова але не потрібно часу на обробку вкладених викликів




/* Написати функцію factorial(n) за допомогою рекурсії (і з використанням оператора ? :), яка повертає факторіал числа n!, наприклад:
alert( factorial(5) ); // 120
Приклади значень для різних факторіалів:
1! = 1
2! = 2 * 1 = 2
3! = 3 * 2 * 1 = 6
4! = 4 * 3 * 2 * 1 = 24
5! = 5 * 4 * 3 * 2 * 1 = 120
...
Факторіал числа - це результат множення одне на одного усіх чисел які стоять від цього числа до 1. Прийнято: факторіал 0 дорівнює 1 
Можна сказати по іншому, – це число, помножене на «себе мінус один», потім на «себе мінус два» и т. д., до одиниці. Позначается n!
Можна факторіал записати загальною формулою: n! = n * (n - 1) * (n - 2) * ...*1
//                                           4! = 4 * (4 - 1) * (4 - 2) * (4 - 3) = 24
*/

// Рішення: тут n! можна записати як n * (n-1)!. Наприклад: 3! = 3*2! = 3*2*1! = 6), 
// function factorial(n) {
//     if (n > 1) {                     // можна було викоритати класичний вираз для рекурсії if (n != 1)
//         return n * factorial(n-1);
//     } 
//     else {
//         return 1;
//     }
// }
// let n = +prompt("Введіть ціле число", "1");
// alert( factorial(n) );

// Рішення через рекурсію з використанням оператора ? : і базисом рекурсії 1
// function factorial(n) {
//     return (n != 1) ? n * factorial(n - 1) : 1;
// }
// alert( factorial(5) ); // виведе: 120

// Рішення через рекурсію з використанням оператора ? : і базисом рекурсії 0
// function factorial(n) {
//     return n ? n * factorial(n - 1) : 1;  // виклик factorial(1) дійде до 1*factorial(0), буде додатковий крок рекурсії
// }
// alert( factorial(5) ); // 120



/* Написати функцію fib(n) за допомогою рекурсії, яка повертає n-е число Фiбоначi, наприклад:
function fib(n) { ... створений код... }
alert( fib(3) ); // 2
alert( fib(7) ); // 13
alert( fib(77)); // 5527939700884757
Числа Фiбоначi тiсно повязане з золотим зрізом і багатьма природніми явищами навколо нас
Будь-яке число з послідовності чисел Фібоначчі отримуєтьсяся у результаті суми двух попередніх і будується по правилy:
n0 = -n2 + -n1; n1 = -1n + n0; n2 = n0 + n1; n3 = n1 + n3. Послiдовнiсть чисел Фiбоначi має формулу Fn = Fn-1 + Fn-2.
Перші два числа рівні 1, потім 2(1+1), далі 3(1+2), 5(2+3) и так длі: 1, 1, 2, 3, 5, 8, 13, 21, 34, ....
Тобто слідуюче число отримуємо в результаті суми двух попередніх:
//     let a = 1;           =  1                                    let a = b;           =  5
//     let b = 1;           =  1                                    let a = b;           =  8
//     let c = a + b;       =  2                                    let с = а + b;       =  13

//     let a = b;           =  1                                    let a = b;           =  8
//     let b = c;           =  2                                    let b = c;           =  13
//     let c = a + b;       =  3                                    let c = a + b;       =  21

//     let a = b;           =  2                                        ...
//     let b = c;           =  3
//     let c = a + b;       =  5
    
//     let a = b;           =  3
//     let b = c;           =  5
//     let c = a + b;       =  8
 */

// Рішення обмежено позитивними значеннями та при великиз значеннях n буде
// вираховувати дуже повільно, а наприклад для fib(77), браузер може і зависнути.
// Це тому, що функція створює широке дерево вкладень викликів, при цьому ряд значень вираховуються багато разів 
// function fib(n) {
//     return n <= 1 ? n : fib(n - 1) + fib(n - 2);        
// }                                                        //
// let n = +prompt("Введіть будь-яке ціле число", "1");
// alert( fib(n) );