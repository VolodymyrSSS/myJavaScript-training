<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>myjs: циклы директивы break/continue</title>
    <style>
    body {
        background-color: tan;
        margin: 0;
        font-family: Verdana, sans-serif;
    }

    .title {
        color: red;
        text-align: center;
        font-weight:700;
    }

    .code-ex {
        width: 50%;
        font-family: sans-serif;
        background-color: #bebebe;
        font-size: large;
        padding-left: 15px;
        margin: 0 auto;
    }

    .task{
        width: 50%;
        padding: 15px 25px;
        color: navy;
        background-color: #e2e2e2;
        margin: 35px auto;
    }

    .code-ex {
        width: 40%;
        font-family: sans-serif;
        background-color: #bebebe;
        font-size: large;
        padding-left: 15px;
        margin: 0 auto;
    }

    p {
        width: 80%;
        margin: 0 auto;
    }
    </style>
</head>
<body>

    <h2 class="title">Basic JS: циклы, break/continue</h2>

    <p>Обычно цикл завершается при вычислении условия в false.<br>
        Но мы можем выйти из цикла в любой момент с помощью специальной директивы <b><em>break</em></b>.<br>
        Например, следующий код подсчитывает сумму вводимых чисел до тех пор, пока посетитель их вводит, 
        а затем – выдаёт:
    </p>

    <p class="code-ex"><br>
        <code>
            let sum = 0;<br>
            while (true) {<br>
             let value = +prompt("Введите число", '');<br>
            if (!value) <b>break;</b> // (*)<br>
            sum += value;<br>
            }<br>
            console.log( 'Сумма: ' + sum );<br>
        </code>
    </p>
    <br>

    <p>Директива break в строке (*) полностью прекращает выполнение цикла и передаёт управление на 
        строку за его телом, то есть на console.log.<br>
        Вообще, сочетание «бесконечный цикл + break» – отличная штука для тех ситуаций, когда условие, 
        по которому нужно прерваться, находится не в начале или конце цикла, а посередине.
    </p>

    <h3>Переход к следующей итерации: continue</h3>

    <p>Директива continue – «облегчённая версия» break. При её выполнении цикл не прерывается, 
        а переходит к следующей итерации (если условие все ещё равно true).
        Её используют, если понятно, что на текущем повторе цикла делать больше нечего.
    </p>

    <h4 class="task">
        У нас есть цыкл от 0 до 10. Выведите только нечётные значения?
    </h4>

    <p class="code-ex"><br>
        <code>
            for (let i = 0; i < 10; i++) {
                ..ваш код..
            }
        </code>
    </p>

    <p><b>Решение</b></p>

    <p>Для решения этой задачи используем директиву continue. Для чётных значений i, 
        директива continue должна прекратить выполнение тела цикла и передать управление 
        на следующую итерацию for (со следующим числом). Таким образом в console.log должны
        попасть только нечётные значения.
    </p>
    <br>

    <p class="code-ex"><br>
        <code>
            for (let i = 0; i < 10; i++) {<br>
                <b>if (i % 2 == 0) continue;</b><br>
                console.log( i );<br>
            }<br>
        </code>
    </p>
    
    <script>
        for (let i = 0; i < 10; i++) {
            if (i % 2 == 0) continue;
            console.log( i );
        }
    </script>

    <p>Цикл, который обрабатывает только нечётные значения, мог бы выглядеть так:</p>

    <p class="code-ex"><br>
        <code>
            for (let i = 0; i < 10; i++) {<br>
                <b>if (i % 2) {<br>
                    console.log( i ); }</b><br>
            }<br>
        </code>
    </p>

    <p>С технической точки зрения он полностью идентичен. Действительно, вместо continue можно 
        просто завернуть действия в блок if. Однако мы получили дополнительный уровень вложенности 
        фигурных скобок. Если код внутри if более длинный, то это ухудшает читаемость, в отличие 
        от варианта с continue. Подчеркнём, <b>директива continue позволяет избегать вложенности</b>.
    </p>

    <p>Нельзя использовать break/continue справа от оператора „?“, это вызовет синтаксическую ошибку.</p>

    <h3>Метки для break/continue</h3>

    <p>Бывает, нужно выйти одновременно из нескольких уровней цикла сразу.<br>
       Например, в коде ниже мы проходимся циклами по i и j, запрашивая с помощью prompt 
       координаты (i, j) с (0,0) до (2,2):
    </p>

    <p class="code-ex"><br>
        <code>
            for (let i = 0; i < 3; i++) {<br>
                for (let j = 0; j < 3; j++) {<br>
                  let input = prompt(`Значение на координатах (${i},${j})`, '');<br>
                  // Что если мы захотим перейти к Готово (ниже) прямо отсюда? }<br>
            }<br>
            console.log('Готово!');<br>
        </code>
    </p>

    <p>Нам нужен способ остановить выполнение если пользователь отменит ввод.<br>
        Обычный break после input лишь прервёт внутренний цикл, но этого недостаточно. 
        Достичь желаемого поведения можно с помощью меток.<br>
        <b>Метка</b> имеет вид идентификатора с двоеточием перед циклом: <b>labelName: for (...) {}</b>
    </p>

    <p>Вызов break 'labelName' в цикле нашего примера ищет ближайший внешний цикл с такой меткой и 
        переходит в его конец. Вот посмотрите:
    </p>

    <p class="code-ex" style="width: 55%;">
        <code>
            <b>outer:</b> for (let i = 0; i < 3; i++) { -здесь outer: наша метка<br>
                for (let j = 0; j < 3; j++) {<br>
                  let input = prompt(`Значение на координатах (${i},${j})`, '');<br>
                  // если пустая строка или Отмена, то выйти из обоих циклов<br>
                  if (!input) break outer; // (*)<br>
                  // сделать что-нибудь со значениями... }<br>
            }<br>
            console.log('Готово!');<br>
        </code>
    </p>

    <p>В примере выше это означает, что вызовом break outer будет разорван внешний цикл до метки с 
        именем outer, и управление перейдёт со строки, помеченной (*), к alert('Готово!').
    </p>

    <p>Можно размещать метку на отдельной строке. Директива continue также может быть использована 
        с меткой. В этом случае управление перейдёт на следующую итерацию цикла с меткой.
    </p>

    <p>Метки не позволяют «прыгнуть» куда угодно. Вызов break/continue возможен только внутри цикла, 
        и метка должна находиться где-то выше этой директивы.
    </p>

    <h4 class="task">
        У нас дан диапазон чисел от 0 до 10. При помощи цикла for выведите чётные числа от 2 до 10.
    </h4>

    <p><b>Решение</b>:</p>

    <p class="code-ex" style="width: 55%;">
        <code>
            for (let i = 2; i <= 10; i++) {<br>
                if (i % 2 == 0) console.log( i );<br>
            }<br>
            console.log( i );<br>
        </code>
    </p>

    <script>
        for (let i = 2; i <= 10; i++) {
            if (i % 2 == 0) console.log( i );
        }
    </script>

    <h4 class="task">
        Натуральное число, большее 1, называется простым, если оно ни на что не делится, кроме себя и 1.<br>
        Другими словами, n > 1 – простое, если при его делении на любое число кроме 1 и n есть остаток.<br>
        Например, 5 это простое число, оно не может быть разделено без остатка на 2, 3 и 4. А вот число 4 - это
        не прстое так как оно может быть разделено на 2 без остатка.<br>
        Напишите код, который выводит все простые числа из интервала от 2 до n.<br>
        Для n = 16 результат должен быть 2,3,5,7,11,13.<br>
        P.S. Код также должен легко модифицироваться для любых других интервалов.
    </h4>

    <p><b>Решение</b>:</p>

    <p>Давайте воспользуемся вложенными циклами, а для этого пропишем вначале алгоритм решения:<br>
        Для всех i от 1 до 16 {<br>
            проверить, делится ли число i на какое-либо из чисел до него<br>
            если делится, то это i не подходит, берём следующее<br>
            если не делится, то i - простое число<br>
        }<br>
    </p>

    <script>
        let n = 16; // задали n
        nextPrime: // задали метку
        for (let i = 2; i <= n; i++) { // Для всех i... (заданный диапазон до n)
            for (let j = 2; j < i; j++) { // взяв любое число до того числа которое хочем определить
                if (i % j == 0) continue nextPrime // если нет остатка то не подходит, берём следующее
            }
        console.log( i ); // простое число
        }
    </script>


</body>

</html>