<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>myjs_reqursion: exercise Вычислить сумму чисел до данного</title>
    <style>
    body {
        background-color: tan;
        margin: 0;
        font-family: Verdana, sans-serif;
    }

    .title {
        color: red;
        text-align: center;
        font-weight:700;
    }

    .code-ex {
        width: 50%;
        font-family: sans-serif;
        background-color: #bebebe;
        font-size: large;
        padding-left: 15px;
        margin: 0 auto;
    }

    .task{
        width: 50%;
        padding: 15px 25px;
        color: navy;
        background-color: #e2e2e2;
        margin: 35px auto;
    }

    .code-ex {
        width: 50%;
        font-family: sans-serif;
        background-color: #bebebe;
        font-size: large;
        padding-left: 15px;
        margin: 0 auto;
    }

    p {
        width: 80%;
        margin: 0 auto;
    }
    </style>
</head>
<body>

    <h2 class="title">myjs_reqursion: Вычислить сумму чисел до данного</h2>

    <h4 class="task">Напишите функцию sumTo(n), которая вычисляет сумму чисел 1 + 2 + ... + n.
        Сделайте три варианта решения:<br>
        С использованием цикла.<br>
        Через рекурсию, т.к. sumTo(n) = n + sumTo(n-1) for n > 1.<br>
        С использованием формулы арифметической прогрессии.<br>
        Какой вариант решения самый быстрый? Самый медленный? Почему? Можно ли при помощи 
        рекурсии посчитать sumTo(100000)?
    </h4>

    <p class="code-ex">Например:<br>
        <code>
            sumTo(1) = 1<br>
            sumTo(2) = 2 + 1 = 3<br>
            sumTo(3) = 3 + 2 + 1 = 6<br>
            sumTo(4) = 4 + 3 + 2 + 1 = 10<br>
            ...<br>
            sumTo(100) = 100 + 99 + ... + 2 + 1 = 5050<br>
        </code>
    </p><br>

    <p><b>Решение</b>:<br><br>
        Для решения с помощью цикла используем стандартный подход цикла for, определив перед этим 
        начальную сумму, которая равна 0. Начальное число в цикле i должно равнятся 1, так как если
        начать с 0 то как сумму, получим это же число 'n', то есть при каждом шаге, 0 будет прибавлятся 
        к числу 'n' n-раз.<br>
    </p><br>

    <p class="code-ex">Решение с помощью цикла <b>for</b><br>
        <code>
            function sumTo(n) {<br>
                let sum = 0;<br>
                <b>for (let i = 1; i <= n; i++) {<br>
                  sum += i;<br>
                }</b><br>
                return sum;<br>
              } <br>   
              <br>
              // проверим работу функции<br>
              console.log(sumTo(1)); // 1<br>
              console.log(sumTo(2)); // 3<br>
              console.log(sumTo(3)); // 6<br>
              console.log(sumTo(4)); // 10<br>
              console.log(sumTo(100)); // 5050<br>
        </code>
    </p><br>

    <script>
        'use strict';

        function sumTo(n) {
          let sum = 0;
          for (let i = 1; i <= n; i++) {
            sum += i;
          }
          return sum;
        }     


        // проверим работу функции
        console.log(sumTo(1)); // 1
        console.log(sumTo(2)); // 3
        console.log(sumTo(3)); // 6
        console.log(sumTo(4)); // 10
        console.log(sumTo(100)); // 5050
    </script>

    <p>
        Так как заданную функцию sumTo(n), для суммы чисел 1 + 2 + ... + n можна ещё представить как 
        sumTo(n) = n + sumTo(n-1) для n > 1, то здесь видно, что в части кода эта структура повторяет 
        саму себя, и это есть рекурсивно определяемая структура данных, которая может быть определена с 
        использованием самой себя. Поэтому мы можем использовать для решения этой задачи рекурсию. Как
        известно, рекурсия означает вызов функции самой себя. Её используют, когда вычисление функции 
        можно свести к её более простому вызову, а его – к ещё более простому и так далее, пока значение 
        не станет очевидно.<br>
        <br>
        Итак, две ветки получить результат:<br>
        Если n == 1, то мы возвращаем 1 - это база рекурсии, потому что сразу же приводит к очевидному 
        результату: при sumTo(1), сумма равна 1;<br>
        Так как заданную функцию sumTo(n), для суммы чисел 1 + 2 + ... + n можна ещё представить как 
        sumTo(n) = n + sumTo(n-1) для n > 1, то тут мы можем свести задачу к более простому действию 
        (прибавления n) и более простой аналогичной задаче (sumTo с меньшим n): n + sumTo(n-1). Последующие 
        шаги упрощают задачу всё больше и больше, пока n не достигает 1 - эта ветка шаг рекурсии который
        мы и возвращаем.
    </p><br>

    <p class="code-ex">Решение с помощью <b>рекурсии</b><br>
        <code>
            function sumTo(n) {<br>
                <b>if (n == 1) {<br>
                    return 1;<br>
                } else {<br>
                    return n + sumTo(n - 1); }</b><br>
            }<br>
              <br>
            // проверим работу функции с рекурсией<br>
            console.log(sumTo(1)); // 1<br>
            console.log(sumTo(2)); // 3<br>
            console.log(sumTo(3)); // 6<br>
            console.log(sumTo2(4)); // 10<br>
            console.log(sumTo2(100)); // 5050<br>
        </code>
    </p><br>

    <script>
        function sumTo2(n) {
          if (n == 1) return 1;
          return n + sumTo2(n - 1);
        }

        // проверим работу функции с рекурсией
        console.log(sumTo2(1)); // 1
        console.log(sumTo2(2)); // 3
        console.log(sumTo2(3)); // 6
        console.log(sumTo2(4)); // 10
        console.log(sumTo2(100)); // 5050
    </script>

    <p>Для решения задачи с использованием формулы арифметической прогрессии, надо определить формулу для 'n'.
        Арифмети́ческая прогрессия - последовательность чисел (членов прогрессии), в которой каждое число, 
        начиная со второго, получается из предыдущего добавлением к нему постоянного числа d - шага, или 
        разности прогрессии: a<sub>n</sub> = a<sub>n-1</sub> + d<br>
        Любой (n-й) член прогрессии может быть вычислен по формуле общего члена:<br>
        a<sub>n</sub> = a1 + (n-1)d<br>
        То есть, Арифмети́ческая прогрессия — это числовая последовательность вида: a1, a1 + d,  a1 + 2d, ...  a1 + (n-1)d, ...,<br>
        Арифметическая прогрессия является монотонной последовательностью. При d > 0 она является возрастающей, 
        а при d < 0 — убывающей. Если d = 0, то последовательность будет стационарной. Эти утверждения следуют 
        из соотношения a<sub>n+1</sub> - a<sub>n</sub> = d для членов арифметической прогрессии.<br>
        <br>
        Из этого, формула для определения суммы членов Арифметической прогрессии:<br>
        sumTo(n) = n*(n+1)/2
    </p><br>


    <p class="code-ex">Решение по формуле: <b>sumTo(n) = n*(n+1)/2</b><br>
        <code>
            function sumTo(n) {
                return n * (n + 1) / 2;
              }
            <br>
            // проверим работу функции с использованием формулы<br>
            console.log(sumTo(1)); // 1<br>
            console.log(sumTo(2)); // 3<br>
            console.log(sumTo(3)); // 6<br>
            console.log(sumTo2(4)); // 10<br>
            console.log(sumTo2(100)); // 5050<br>
        </code>
    </p><br>

    <script>
        function sumTo3(n) {
          return n * (n + 1) / 2;
        }

        // проверим работу функции с использованием формулы
        console.log(sumTo3(1)); // 1
        console.log(sumTo3(2)); // 3
        console.log(sumTo3(3)); // 6
        console.log(sumTo3(4)); // 10
        console.log(sumTo3(100)); // 5050
    </script>

    <p>Решение по формуле работает быстрее всех. Это очевидно. Оно использует всего три операции для 
        любого n, а цикл и рекурсия требуют как минимум n операций сложения. Вариант с циклом – второй 
        по скорости. Он быстрее рекурсии, так как операций сложения столько же, но нет дополнительных 
        вычислительных затрат на организацию вложенных вызовов. Поэтому рекурсия в данном случае работает 
        медленнее всех.
    </p><br>

    <p>Некоторые движки поддерживают оптимизацию «хвостового вызова»: если рекурсивный вызов является 
        самым последним в функции (как в sumTo выше), то внешней функции не нужно будет возобновлять 
        выполнение и не нужно запоминать контекст его выполнения. В итоге требования к памяти снижаются, 
        и сумма sumTo(100000) будет успешно вычислена. <br>
        Но если JavaScript-движок не поддерживает это (большинство не поддерживают), будет ошибка: 
        максимальный размер стека превышен, так как обычно существует ограничение на максимальный 
        размер стека.<br>
        <br>
        Проверим:<br>
    </p><br>

    <p class="code-ex">Проверка работы функции с рекурсией для n = 100000</b><br>
        <code>
            console.log(sumTo(100000)); // Maximum call stack size exceeded<br>
        </code>
    </p><br>

    <script>
        // проверим работу функции с рекурсией
        console.log(sumTo2(100000)); // Maximum call stack size exceeded
    </script>

</body>

</html>