<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>myjs_funcAdv: exercise Замыкание</title>
    <style>
    body {
        background-color: tan;
        margin: 0;
        font-family: Verdana, sans-serif;
    }

    .title {
        color: red;
        text-align: center;
        font-weight:700;
    }

    .code-ex {
        width: 50%;
        font-family: sans-serif;
        background-color: #bebebe;
        font-size: large;
        padding-left: 15px;
        margin: 0 auto;
    }

    .task{
        width: 50%;
        padding: 15px 25px;
        color: navy;
        background-color: #e2e2e2;
        margin: 35px auto;
    }

    .code-ex {
        width: 50%;
        font-family: sans-serif;
        background-color: #bebebe;
        font-size: large;
        padding-left: 15px;
        margin: 0 auto;
    }

    p {
        width: 80%;
        margin: 0 auto;
    }
    </style>
</head>
<body>

    <h2 class="title">myjs_funcAdv: exercise Замыкание</h2>

    <h4 class="task">Мы знаем, что функция может получить доступ к переменным из внешнего окружения, эта возможность 
        используется очень часто.<br>
        У нас есть функция makeCounter, которая присваиваетса новому объекту в конструкторе.
        Эта функция имеет вложенную функцию, которая возвращает следующее число при каждом вызове.<br>
        <br>
        Вопрос 1: можем ли мы каким-нибудь образом сбросить счётчик count из кода, который не принадлежит makeCounter 
        (например, после вызова console.log в коде ниже) ?<br>
        <br>
        Вопрос 2: если мы вызываем makeCounter несколько раз – нам возвращается много функций counter. Они независимы или 
        разделяют одну и ту же переменную count ?<br>
    </h4>

    <p class="code-ex">
        <code>
            function makeCounter() {<br>
                <b>let count = 0;</b><br>
                <br>
                return function() {<br>
                  return count++; };<b> - есть доступ к внешней переменной 'count'</b><br>
            }<br>
            <br>
            let counter = makeCounter();<br>
            <br>
            console.log( counter() ); // 0<br>
            console.log( counter() ); // 1<br>
            console.log( counter() ); // 2<br>
        </code>
    </p><br>

    <p><b>Ответ1</b>:<br>
        <br>
        Такой возможности нет: count – локальная переменная функции, мы не можем получить к ней доступ извне.
        В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект, 
        называемый лексическим окружением LexicalEnvironment. Внутреннее лексическое окружение для вложенной функции 
        соответствует текущему выполнению этой функции, которое возвращает следующее число. В нём нету переменных. 
        Внешнее лексическое окружение для вложенной функции – это переменные внешней функции makeCounter.
        В нём находятся переменная count и вложенная функция. У внутреннего лексического окружения есть ссылка outer на внешнее.<br>
        Когда внутренняя функция начинает выполняться, начинается поиск переменной count++ изнутри-наружу. Порядок будет такой:<br>
        1. Локальные переменные вложенной функции…<br>
        2. Переменные внешней функции…<br>
        3. И так далее, пока не будут достигнуты глобальные переменные.<br>
        <br>
        То есть - когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении, 
        затем во внешнем, затем в следующем и так далее, до глобального.<br>
        В этом случае count будет найден на шаге 2. Когда внешняя переменная модифицируется, она изменится там, где была найдена. 
        Значит, count++ найдёт внешнюю переменную и увеличит её значение в лексическом окружении, которому она принадлежит. Как если 
        бы у нас было let count = 1.<br>
    </p><br>

    <p><b>Ответ2</b>:<br>
        Для каждого вызова makeCounter() создаётся новое лексическое окружение функции, со своим собственным 
        count. Так что, получившиеся функции counter – независимы.<br>
        Все функции «при рождении» получают скрытое свойство [[Environment]], которое ссылается на лексическое 
        окружение места, где они были созданы. В данном случае, makeCounter создан в глобальном лексическом 
        окружении, так что [[Environment]] содержит ссылку на него.<br>
        Код продолжает выполняться, объявляется новая глобальная переменная counter, которой присваивается 
        результат вызова makeCounter.<br>
        В момент вызова makeCounter() создаётся лексическое окружение, для хранения его переменных и аргументов.
        Как и все лексические окружения, оно содержит две вещи:<br>
        Environment Record с локальными переменными. В нашем случае count – единственная локальная переменная 
        (появляющаяся, когда выполняется строчка с let count).
        Ссылка на внешнее окружение, которая устанавливается в значение [[Environment]] функции. В данном 
        случае, [[Environment]] функции makeCounter ссылается на глобальное лексическое окружение.<br>
        В процессе выполнения makeCounter() создаётся небольшая вложенная функция. Не имеет значения, какой 
        способ объявления функции используется: Function Declaration или Function Expression. Все функции 
        получают свойство [[Environment]], которое ссылается на лексическое окружение, в котором они были 
        созданы. То же самое происходит и с нашей новой маленькой функцией. Для нашей новой вложенной функции 
        значением [[Environment]] будет текущее лексическое окружение makeCounter() (где она была создана).<br>
        Выполнение продолжается, вызов makeCounter() завершается, и результат (небольшая вложенная функция) 
        присваивается глобальной переменной counter. В этой функции есть только одна строчка: return count++, 
        которая будет выполнена, когда мы вызовем функцию.<br>
        При вызове counter() для этого вызова создаётся новое лексическое окружение. Оно пустое, так как в 
        самом counter локальных переменных нет. Но [[Environment]] counter используется, как ссылка на 
        внешнее лексическое окружение outer, которое даёт доступ к переменным предшествующего вызова 
        makeCounter, где counter был создан.<br>
        Теперь, когда вызов ищет переменную count, он сначала ищет в собственном лексическом окружении 
        (пустое), а затем в лексическом окружении предшествующего вызова makeCounter(), где и находит её.<br>
        Вызов counter() не только возвращает значение count, но также увеличивает его. Mодификация происходит
         «на месте». Значение count изменяется конкретно в том окружении, где оно было найдено.<br>
         Следующие вызовы counter() сделают то же самое.
    </p><br>

    <p class="code-ex">
        <code>
            function makeCounter() {<br>
                <b>let count = 0;</b><br>
                return function() {<br>
                    return count++;};<br>
            }<br>
            <br>
            let counter1 = makeCounter();<br>
            <b>let counter2 = makeCounter();</b><br>
            <br>
            console.log( counter1() ); // 0<br>
            console.log( counter1() ); // 1<br>
            console.log( counter1() ); // 2<br>
            console.log( counter1() ); // 3<br>
            <br>
            console.log( <b>counter2()</b> ); // <b>0 (независимо)</b><br>
        </code>
    </p><br>

    <script>
        function makeCounter() {
            let count = 0;
            return function() {
                return count++;};
        }
        
        let counter1 = makeCounter();
        let counter2 = makeCounter();
        
        console.log( counter1() ); // 0
        console.log( counter1() ); // 1
        console.log( counter1() ); // 2
        console.log( counter1() ); // 3
        
        console.log( counter2() ); // 0 (независимо)
    </script>

    <p>A вот в этом примере, функция work() в коде ниже получает name из того места, где была создана, 
        через ссылку на внешнее лексическое окружение - результатом будет 'Sigizmund'.
    </p><br>

    <p class="code-ex">
        <code>
            function makeWorker() {<br>
                <b>let name = 'Sigizmund';</b><br>
                return function() {<br>
                    console.log(name);};<br>
            }<br>
            <br>
            let name = 'Mosha';<br>
            <b>let work = makeWorker();</b><br>
            <br>
            <b>work();</b> // Sigizmund<br>
        </code>
    </p><br>

    <script>
        function makeWorker() {
          let name = "Sigizmund";
          return function() {
            console.log(name);};
        }
            
        let name = "Mosha";
        let work = makeWorker();
            
        work(); // Sigizmund
    </script>

    <p>Но, если бы в makeWorker() не было let name, тогда бы поиск продолжился дальше и была бы взята 
        глобальная переменная, как мы видим из приведённой выше цепочки. В таком случае, результатом было 
        бы 'Mosha'.
    </p><br>

    <p>В большинстве случаев, объект лексического окружения существует до того момента, пока есть функция, 
        которая может его использовать. И только тогда, когда таких не остаётся, окружение уничтожается.
    </p>

    <p>В программировании есть общий термин: «замыкание», – которое должен знать каждый разработчик.<br>
        Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. 
        В некоторых языках это невозможно, или функция должна быть написана специальным образом, чтобы 
        получилось замыкание. Но, как было описано выше, в JavaScript, все функции изначально являются 
        замыканиями (есть только одно исключение).<br>
        То есть, они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]] 
        и все они могут получить доступ к внешним переменным.<br>
        Когда на собеседовании фронтенд-разработчик получает вопрос: «что такое замыкание?», – правильным 
        ответом будет определение замыкания и объяснения того факта, что все функции в JavaScript являются 
        замыканиями, и, может быть, несколько слов о технических деталях: свойстве [[Environment]] и о том, 
        как работает лексическое окружение.
    </p><br>



</body>

</html>