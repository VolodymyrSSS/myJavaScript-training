<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>myjs-structure: WeakMap и WeakSet</title>
    <style>
    body {
        background-color: tan;
        margin: 0;
        font-family: Verdana, sans-serif;
    }

    .title {
        color: red;
        text-align: center;
        font-weight:700;
    }

    .code-ex {
        width: 50%;
        font-family: sans-serif;
        background-color: #bebebe;
        font-size: large;
        padding-left: 15px;
        margin: 0 auto;
    }

    .task{
        width: 50%;
        padding: 15px 25px;
        color: navy;
        background-color: #e2e2e2;
        margin: 35px auto;
    }

    .code-ex {
        width: 50%;
        font-family: sans-serif;
        background-color: #bebebe;
        font-size: large;
        padding-left: 15px;
        margin: 0 auto;
    }

    p {
        width: 80%;
        margin: 0 auto;
    }
    </style>
</head>
<body>

    <h2 class="title">myjs-structure: WeakMap и WeakSet</h2>

    <p>Как мы знаем, движок JavaScript хранит значения в памяти до тех пор, пока они достижимы (то есть, эти 
        значения могут быть использованы).
    </p>

    <p class="code-ex" style="width: 60%;">Например:<br>
        <code>
            let john = { name: "John" }; -объект доступен, переменная john - это ссылка на него<br>
            <br>
            john = null; -перепишем ссылку<br>

            // <b>объект будет удалён из памяти</b><br>
        </code>
    </p><br>

    <p>Обычно свойства объекта, элементы массива или другой структуры данных считаются достижимыми и сохраняются в 
        памяти до тех пор, пока эта структура данных содержится в памяти. Например, если мы поместим объект в массив, 
        то до тех пор, пока массив существует, объект также будет существовать в памяти, несмотря на то, что других ссылок 
        на него нет.
    </p><br>

    <p class="code-ex">Например:<br>
        <code>
            let john = { name: "John" };<br>
            <br>
            <b>let array = [ john ];</b><br>
            <br>
            john = null; -перезаписываем ссылку на объект<br>
            <br>
            // <b>объект john хранится в массиве, поэтому он не будет удалён</b> сборщиком мусора<br>
            // мы можем взять его значение как array[0]<br>
        </code>
    </p><br>

    <p>Аналогично, если мы используем объект как ключ в Map, то до тех пор, пока существует Map, также будет существовать 
        и этот объект. Он занимает место в памяти и не может быть удалён сборщиком мусора.
    </p><br>

    <p class="code-ex">
        <code>
            let john = { name: 'John' };<br>
            <br>
            <b>let map = new Map();<br>
            map.set(john, '...');</b><br>
            <br>
            john = null; -перезаписываем ссылку на объект<br>
            <br>
            // объект john сохранён внутри объекта 'Map',<br>
            // он доступен через map.keys()<br>
        </code>
    </p><br>

    <h3>WeakMap</h3>

    <p>WeakMap – принципиально другая структура в этом аспекте. Она не предотвращает удаление объектов сборщиком мусора, 
        когда эти объекты выступают в качестве ключей.
    </p><br>

    <p>Первое его отличие от Map в том, что <b>ключи в WeakMap должны быть объектами</b>, а не примитивными значениями:</p><br>

    <p class="code-ex">
        <code>
            let weakMap = new WeakMap();<br>
            <br>
            <b>let obj = {};</b><br>
            <br>
            weakMap.set(<b>obj</b>, 'ok'); // работает (объект в качестве ключа)<br>
            <br>
            // нельзя использовать строку в качестве ключа<br>
            weakMap.set(<b>'test'</b>, 'Whoops');<br>
            // TypeError: Invalid value used as weak map key, потому что 'test' не объект<br>
        </code>
    </p><br>

    <p>Теперь, если мы используем объект в качестве ключа и если больше нет ссылок на этот объект, то он будет удалён 
        из памяти (и из объекта WeakMap) автоматически.
    </p><br>

    <p class="code-ex">
        <code>
            let john = { name: "John" };<br>
            <br>
            let weakMap = new WeakMap();<br>
            weakMap.set(<b>john</b>, "...");<br>
            <br>
            john = null; -перезаписываем ссылку на объект<br>
            <br>
            // <b>объект john удалён из памяти!</b><br>
        </code>
    </p><br>

    <p>Сравните это поведение с поведением обычного Map, пример которого был приведён ранее.<br> 
        Теперь john существует только как ключ в WeakMap и может быть удалён оттуда автоматически.<br>
        <b>WeakMap не поддерживает перебор и методы keys(), values(), entries(),</b> так что нет способа взять все ключи 
        или значения из неё.
    </p><br>

    <p>В WeakMap присутствуют только следующие методы:</p><br>

    <p class="code-ex">
        <code>
            weakMap.get(key)<br>
            weakMap.set(key, value)<br>
            weakMap.delete(key)<br>
            weakMap.has(key)<br>
        </code>
    </p><br>

    <p>К чему такие ограничения? Из-за особенностей технической реализации. Если объект станет недостижим 
        (как объект john в примере выше), то он будет автоматически удалён сборщиком мусора. Но нет информации, 
        в какой момент произойдёт эта очистка.<br>
        Решение о том, когда делать сборку мусора, принимает движок JavaScript. Он может посчитать необходимым 
        как удалить объект прямо сейчас, так и отложить эту операцию, чтобы удалить большее количество объектов 
        за раз позже. Так что технически количество элементов в коллекции WeakMap неизвестно. Движок может произвести 
        очистку сразу или потом, или сделать это частично. По этой причине методы для доступа ко всем сразу ключам/значениям 
        недоступны.
    </p><br>

    <p><b>Но для чего же нам нужна такая структура данных?</b></p><br>

    <p>В основном, WeakMap используется в качестве <b>дополнительного хранилища данных</b>.<br>
        Если мы работаем с объектом, который «принадлежит» другому коду, может быть даже сторонней библиотеке, и хотим 
        сохранить у себя какие-то данные для него, которые должны существовать лишь пока существует этот объект, то 
        WeakMap – как раз то, что нужно.
    </p><br>

    <p>Мы кладём эти данные в WeakMap, используя объект как ключ, и когда сборщик мусора удалит объекты из памяти, 
        ассоциированные с ними данные тоже автоматически исчезнут.
    </p><br>

    <p class="code-ex" style="width: 60%;">
        <code>
            weakMap.set(john, 'секретные документы');<br>
            // если john умрёт, 'секретные документы' будут автоматически уничтожены<br>
        </code>
    </p><br>

    <p>Давайте рассмотрим один пример.<br>
        Предположим, у нас есть код, который ведёт учёт посещений для пользователей. Информация хранится в коллекции Map: 
        объект, представляющий пользователя, является ключом, а количество визитов – значением. Когда пользователь нас 
        покидает (его объект удаляется сборщиком мусора), то больше нет смысла хранить соответствующий счётчик посещений.
    </p><br>

    <p>Пример реализации счётчика посещений с использованием Map:</p><br>

    <p class="code-ex">
        <code>
            // 📁 visitsCount.js<br>
            let visitsCountMap = new Map(); // map: пользователь => число визитов<br>
            <br>
            // увеличиваем счётчик<br>
            function countUser(user) {<br>
                let count = visitsCountMap.get(user) || 0;<br>
                visitsCountMap.set(user, count + 1);<br>
            }<br>
        </code>
    </p><br>

    <p>А вот другая часть кода, возможно, в другом файле, которая использует countUser:</p><br>

    <p class="code-ex">
        <code>
            // 📁 main.js<br>
            let john = { name: 'John' };<br>
            <br>
            countUser(john); //ведём подсчёт посещений<br>
            <br>
            // пользователь покинул нас<br>
            john = null;<br>
        </code>
    </p><br>

    <p>Теперь объект john должен быть удалён сборщиком мусора, но он продолжает оставаться в памяти, так как является 
        ключом в visitsCountMap.<br>
        Нам нужно очищать visitsCountMap при удалении объекта пользователя, иначе коллекция будет бесконечно расти.<br> 
        Подобная очистка может быть неудобна в реализации при сложной архитектуре приложения.<br>
        Проблемы можно избежать, если использовать WeakMap:
    </p><br>

    <p class="code-ex" style="width: 60%;">
        <code>
            // 📁 visitsCount.js<br>
            let visitsCountMap = <b>new WeakMap()</b>; // map: пользователь => число визитов<br>
            <br>
            // увеличиваем счётчик<br>
            function countUser(user) {<br>
                let count = visitsCountMap.get(user) || 0;<br>
                visitsCountMap.set(user, count + 1);<br>
            }<br>
        </code>
    </p><br>

    <p>Теперь нет необходимости вручную очищать visitsCountMap. После того, как объект john стал недостижим другими 
        способами, кроме как через WeakMap, он удаляется из памяти вместе с информацией по такому ключу из WeakMap.
    </p><br>
    <br>

    <p>Другая частая сфера применения – это <b>кеширование</b>, когда результат вызова функции должен где-то 
        запоминаться («кешироваться») для того, чтобы дальнейшие её вызовы на том же объекте могли просто 
        брать уже готовый результат, повторно используя его.<br>
        <br>
        Для хранения результатов мы можем использовать Map, вот так:
    </p><br>

    <p class="code-ex">
        <code>// 📁 cache.js<br>
            <br>
            let cache = <b>new Map();</b><br>
            <br>
            // вычисляем и запоминаем результат<br>
            function process(obj) {<br>
            if (!cache.has(obj)) {<br>
                let result = /* тут какие-то вычисления результата для объекта */ obj;<br>
                <br>
                cache.set(obj, result);<br>
                }<br>
            <br>
            return cache.get(obj);<br>
            }<br>
        </code>
    </p><br>

    <p>Теперь используем process() в другом файле:</p><br>

    <p class="code-ex">📁 main.js<br>
        <code>
            let obj = {/* допустим, у нас есть какой-то объект */};<br>
            <br>
            let result1 = process(obj); // вычислен результат<br>
            <br>
            // ...позже, из другого места в коде...<br>
            let result2 = process(obj); // ранее вычисленный результат взят из кеша<br>
            <br>
            // ...позже, когда объект больше не нужен:<br>
            obj = null;<br>
            <br>
            console.log(<b>cache.size</b>); // <b>1</b> -Упс! Объект всё ещё в кеше, занимает память!<br>
        </code>
    </p><br>

    <p>Многократные вызовы process(obj) с тем же самым объектом в качестве аргумента ведут к тому, что 
        результат вычисляется только в первый раз, а затем последующие вызовы берут его из кеша. Недостатком 
        является то, что необходимо вручную очищать cache от ставших ненужными объектов.
    </p><br>

    <p>Но если мы будем использовать WeakMap вместо Map, то эта проблема исчезнет: закешированные результаты 
        будут автоматически удалены из памяти сборщиком мусора.
    </p><br>

    <p class="code-ex">
        <code>// 📁 cache.js<br>
            <br>
            let cache = <b>new WeakMap()</b>;<br>
            <br>
            // вычисляем и запоминаем результат<br>
            function process(obj) {<br>
            if (!cache.has(obj)) {<br>
                let result = /* тут какие-то вычисления результата для объекта */ obj;<br>
                <br>
                cache.set(obj, result);<br>
                }<br>
            <br>
            return cache.get(obj);<br>
            }<br>
        </code>
    </p><br>


    <p>Теперь, используем process() в другом файле:</p><br>

    <p class="code-ex">📁 main.js<br>
        <code>
            let obj = {/* допустим, у нас есть какой-то объект */};<br>
            <br>
            let result1 = process(obj);<br>
            let result2 = process(obj);<br>
            <br>
            // ...позже, когда объект больше не нужен:<br>
            obj = null;<br>
            <br>
            // <b>Нет возможности получить cache.size</b>, так как это WeakMap,<br>
            // но он равен 0 или скоро будет равен 0<br>
            // Когда сборщик мусора удаляет obj, связанные с ним данные из кеша тоже удаляются<br>
        </code>
    </p><br>

    <h3>WeakSet</h3>

    <p>Коллекция WeakSet ведёт себя похоже:<br>
        <br>
        1. Она аналогична Set, но мы можем добавлять в WeakSet только объекты (не примитивные значения).<br>
        2. Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.<br>
        3. Как и Set, она <b>поддерживает add, has и delete</b>, но не size, keys() и <b>не является 
            перебираемой</b>.
    </p><br>

    <p>Будучи «слабой» версией оригинальной структуры данных, она тоже <b>служит в качестве дополнительного 
        хранилища</b>. Но не для произвольных данных, а скорее для значений типа «да/нет». Присутствие во 
        множестве WeakSet может что-то сказать нам об объекте.
    </p><br>

    <p>Например, мы можем добавлять пользователей в WeakSet для учёта тех, кто посещал наш сайт:</p><br>

    <p class="code-ex">
        <code>
            let visitedSet = <b>new WeakSet()</b>;<br>
            <br>
            let john = { name: 'John' };<br>
            let pete = { name: 'Pete' };<br>
            let mary = { name: 'Mary' }; <br>
            <br>
            visitedSet.add(john); // John заходил к нам<br>
            visitedSet.add(pete); // потом Pete<br>
            visitedSet.add(john); // John снова<br>
            <br>
            // visitedSet сейчас содержит двух пользователей<br>
            <br>
            // проверим, заходил ли John?<br>
            console.log(visitedSet.has(john)); // true<br>
            <br>
            // проверим, заходила ли Mary?<br>
            console.log(visitedSet.has(mary)); // false<br>
            <br>
            john = null;<br>
            <br>
            // структура данных visitedSet будет очищена автоматически<br>
        </code>
    </p><br>

    <h3>Иього</h3>

    <p>WeakMap – это Map-подобная коллекция, позволяющая использовать в качестве ключей только объекты, 
        и автоматически удаляющая их вместе с соответствующими значениями, как только они становятся 
        недостижимыми иными путями.<br>
        <br>
        WeakSet – это Set-подобная коллекция, которая хранит только объекты и удаляет их, как только они 
        становятся недостижимыми иными путями.<br>
        <br>
        Обе этих структуры данных не поддерживают методы и свойства, работающие со всем содержимым сразу или 
        возвращающие информацию о размере коллекции. Возможны только операции на отдельном элементе коллекции.<br>
        <br>
        WeakMap и WeakSet используются как вспомогательные структуры данных в дополнение к «основному» месту 
        хранения объекта. Если объект удаляется из основного хранилища и нигде не используется, кроме как в 
        качестве ключа в WeakMap или в WeakSet, то он будет удалён автоматически.
    </p><br>

</body>

</html>