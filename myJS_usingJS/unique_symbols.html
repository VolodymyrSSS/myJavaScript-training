<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Check for uniques symbols</title>
    <style>
      body {
        background-color: tan;
        margin: 0;
        font-family: Verdana, sans-serif;
      }

      .emph {
        color: red;
      }

      .title {
        color: navy;
        text-align: center;
        font-weight: 700;
      }

      .task {
        width: 50%;
        padding: 15px 25px;
        color: navy;
        background-color: #e2e2e2;
        margin: 35px auto;
      }

      p {
        width: 80%;
        margin: 0 auto;
      }

      pre {
        width: 50%;
        background-color: #bebebe;
        padding-top: 20px;
        margin: 0 auto;
      }

      code {
        font-family: Arial, Helvetica, sans-serif;
        font-size: large;
      }

      .code-ex {
        width: 50%;
        font-family: sans-serif;
        font-style: italic;
        background-color: #bebebe;
        font-size: large;
        padding-left: 15px;
        margin: 0 auto;
      }
    </style>
  </head>

  <body>
    <h2 class="title">Uniqueness of all characters in a string</h2>
    <h4 class="title">Working with strings: using loop <span class="emph">for</span>, condition operator <span class="emph">if</span>, method <span class="emph">str.lastIndexOf(substr, pos)</span> and<br/>
      the methods of the collection <span class="emph">new Set(iterable)</span> as:<span class="emph">, set.has(value), set.add(value), set.size</span></h4>

    <h4 class="task">
      Напишіть функцію isUnique(string), яке буде перевіряти чи особливі символи у рядку.<br/>
      При вирішенні задачі, регістр символа повинен бути врахований.<br/>
    </h4>

    <p>
      <code>
        <pre>
          isUnique('abcdef'); // true
          isUnique('abcABC'); // true
          isUnique('123456789'); // true
          isUnique('artyfact'); // false
          isUnique('374514'); // false
          isUnique('ABBA'); // false
          isUnique('rose'); // true
        </pre>
      </code>
    </p><br>

    <p><b>Рішення:</b></p><br>

    <p>Визначаємо основний алгоритм вирішення: будемо брати по черзі символ слово-виразу та порівнювати його з остальними символами. Якщо при порівнянні немає такого самого, то він унікальний.<br/>
    Отже, спочатку потрібно пройтись по всьому слово-виразу щоб мати доступ до конкретного символа і далі його перевіряти на унікальність. Це можемо зробити за допомогою простого циклу <b>for</b>, та доступ до символів отримаємо після проходження по символам в циклі як <em>string[i]</em>, при цьому задамо змінну, яка своїм значенням отримає конкретний символ, ось так:</p><br>

    <p class="code-ex">
      <code>
        <pre>
          function isUnique(string) {
            for(let i=0; i< string.length; i++) {
             const char = string[i];
            }

            return true;
          };
        </pre>
      </code>
    </p><br>

    <p>Далі, подивимось чи ми можемо використати метод для слово-виразів як <b>str.indexOf(substr, pos)</b>, який шукає підрядок substr у рядку str, починаючи з позиції pos, і повертає позицію(індекс), на якій є співпадіння, або -1 за відсутності збігів.<br/>
    Тобто можна задати умову при якій метод буде шукати символ і якщо він повертає -1 то такого символу не було знайдено і поверне false, ось так:</p><br>

    <p class="code-ex">
      <code>
        <pre style="width:60%">
          if (string.indexOf(char) === -1) return false;
        </pre>
      </code>
    </p><br>

    <p>Але, тут методом взявши перший символ, одразу буде повернуто його позицію, тому краще пошук здійснювати з кінця слово-виразу, а для цього є такийц метод як <b>str.lastIndexOf(substr, pos)</b> ось так:</p><br>

    <p class="code-ex">
      <code>
        <pre style="width:60%">
          if (string.lastIndexOf(char) === -1) return false;
        </pre>
      </code>
    </p><br>

    <p>Проте це все рівно не вирішить завдання, бо ми все-рівно знайдемо наявність символу, а нам потрібно знати що в слово-виразі більше не має інших таких самих символів. Тому потрібно змінити умову на таку, яка буде визначати, чи не має ще таких самих символів, або знайдена інша позиція з таким самим символом.<br/> 
    Для цього поміняємо умову де вкажемо, що якщо знайдена позиція(індекс) не буде дорівнювати поточній позиції символу, тільки тоді повертати false, ось так:</p><br/>

    <p class="code-ex">
      <code>
        <pre>
          if (string.lastIndexOf(char) !== i) return false;
        </pre>
      </code>
    </p><br>

    <p>І кінцевий код з використанням цього методу буде мати вид:</p><br>

    <p class="code-ex">
      <code>
        <pre>
          function isUnique(string) {
            for(let i=0; i< string.length; i++) {
             const char = string[i];
             
             // якщо знайдений індекс не дорівнює поточному індексу
             if (string.lastIndexOf(char) !== i) { 
              return false;
            }

            return true;
          };
          
        </pre>
      </code>
    </p><br>

    <p>Але увага, при застосуванні такого рішення, перевірка <em>isUnique('3745142');</em> повертає true - а це не вірно! Це не унікальний слово-вираз бо є два символи "4".</p><br/>

    <p><b>інший варіант:</b></p><br>

    <p>За основу для рішення візьмемо об'єкт <b>Set</b> - це особливий вид колекції: "множина" значень (без ключів), де кожне значення може з'являтися тільки один раз.<br/>
    Отже, створимо таку унікальну колекцію її методом <em>new Set();</em>, та присвоїмо змінній set цю колекцію, ось так:</p><br>

    <p class="code-ex">
      <code>
        <pre>
          function isUnique(string) {
            const set = new Set();

            for(let i=0; i< string.length; i++) {
             const char = string[i];
             
            return true;
          };
        </pre>
      </code>
    </p><br>

    <p>Далі в блоці цикла ми будемо також задавати умову використавши метод Set, як <b>set.has(value)</b>, який повертає true, якщо значення є у множині, інакше false. Тобто, ми повертаємо false якщо символ у слововиразі є, а якщо немає, то ми повинні додати його до колекції методом Set, як <b>set.add(value)</b>, який додає значення (якщо воно вже є, то нічого не робить), повертає той самий об'єкт Set. Тут треба наголосити, що основна особливість є те, що при повторних викликах set.add() з одним і тим самим значенням нічого не відбувається, за рахунок цього якраз і виходить, що кожне значення виникає тільки один раз. Тому додамо значення до новоствореної колекції, ось так:
    </p><br>

    <p class="code-ex">
      <code>
        <pre>
          function isUnique(string) {
            const set = new Set();

            for(let i=0; i< string.length; i++) {
             const char = string[i];

             // якщо є символ в колекції
             if(set.has(char)) {
               return false;
              }

             // якщо немає, то його потрібно додати до новоствореної колекції set
             set.add(char)
            }
             
            return true;
          };
        </pre>
      </code>
    </p><br>

    <p>Проте, в нашому випадку при створенні колекції set ми можемо одразу задавати аргументом слово-вираз, бо якщо в якосі аргумента був переданий якийсь ітеруємий об'єкт, то колекція Set копіює усі значення цього об'єкта в новий Set методом <b>new Set(iterable)</b> - це значить, що робить автоматично кожен символ унікальним. І якщо є в слововиразі два одинакових символа, то в колекції буде зберігатись тільки один.<br/>
    Але що це нам загалом може дати? А те, що ми далі можемо порівняти довжину цього set та довжину слово-виразу, якщо вони різні, то це значить що є в слово-виразі подібні символи, а колекція set буде зберігати тільки унікальні символи і подібних символів не містить. Тому використаємо метод Set як <b>set.size</b>, який повертає кількість елементів у множині Set. Для визначення довжини слово-виразу, використаємо властивість <b>str.length</b>. Кінцевий вид коду буде мати вид:
    </p><br>

    <p class="code-ex">
      <code>
        <pre>
          function isUnique(string) {
            return new Set(string).size === string.length;
          };
        </pre>
      </code>
    </p><br/><br/><br/>


    <script>

      // =================================================

      function isUnique(string) {
        for(let i=0; i< string.length; i++) {
          const char = string[i];
          
          // якщо знайдений індекс не дорівнює поточному індексу
          if (string.lastIndexOf(char) !== i) {
            return false;
          }

          return true;
        };
      }

      console.log('abcdef - ', isUnique('abcdef')); // true;
      console.log('abcABC - ', isUnique('abcABC')); // true
      console.log('123456789 - ', isUnique('123456789')); // true
      console.log('artyfact - ', isUnique('artyfact')); // false
      console.log('3745142 - ', isUnique('3745142')); // false
      console.log('ABBA - ', isUnique('ABBA')); // false
      console.log('rose - ', isUnique('rose')); // true

      // =================================================

      function isUnique2(string) {
        const set = new Set();

        for(let i=0; i< string.length; i++) {
          const char = string[i];

          // якщо є символ в колекції
          if(set.has(char)) {
            return false;
          }

          // якщо немає, то його потрібно додати до новоствореної колекції set
          set.add(char)
        }
          
        return true;
      };

      console.log('abcdef - ', isUnique2('abcdef')); // true;
      console.log('abcABC - ', isUnique2('abcABC')); // true
      console.log('123456789 - ', isUnique2('123456789')); // true
      console.log('artyfact - ', isUnique2('artyfact')); // false
      console.log('3745142 - ', isUnique2('3745142')); // false
      console.log('ABBA - ', isUnique2('ABBA')); // false
      console.log('rose - ', isUnique2('rose')); // true


    </script>
  </body>
</html>
