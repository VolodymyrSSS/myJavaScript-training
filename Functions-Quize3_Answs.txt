Task 1
const name = "Ben"
function sayHi() {
   console.log(name);
}
setTimeout(function() {
   const name = "John";
   sayHi();
}, 1000);

/* in this case, the concept of closure is at play. The 
"sayHi" function retains access to the lexical scope in 
which it was defined, and it "closes over" the variable 
"name". Even though a new variable named "name" is 
declared inside the setTimeout callback, it does not 
affect the name variable that "sayHi" has access to, 
thanks to closure */
Answer: Ben


Task 2
let person = {name: “Noren Red”}
const members = [person];
person = null;
console.log(members);

/*in reality, we are only setting new reference to person
variable, not to members variable. That is why previous 
reference will be used in members array.
In Short, { name: "Noren Red"} lives in some 
memory space whose address is X201 and this is how 
referencing is working
let person = X201
const members = [ X201 ]
person = null */
Answer: [{name: “Noren Red”}]

Task 3
const name = "John";
const user = {
   name: "Ben",
   getName() {
      return this.name;
   }
}
const getUserName = user.getName;
console.log(getUserName());

/* the variable "name" is declared with the value "John"
in the outer scope. An object "user" is created with a 
"name" property set to "Ben" and a method "getName"
that returns "this.name". The method "getName" relies 
on the "this" context, so when it's invoked as 
"user.getName()", it correctly returns "Ben". 
However, when "getUserName" is assigned the value of 
"user.getName", it loses its binding to the "user" object. 
Now, "getUserName" is just a reference to the function 
"getName" without any specific context. When 
"getUserName()" is invoked, it's essentially like calling 
the standalone function "user.getName()" without the 
object context. This results in an attempt to access 
"this.name", but this is not bound to any object or we 
can say  "this" is not bound to the "user" object. Therefore,
the attempt to access "this.name" may results in 
"undefined" or even throw an Error */
Answer: undefined or Error

Task 4
const foo = 1;
function bar() {
   console.log(foo);
   const foo = 10;
}
bar();

/* in JavaScript, both "var" and "function" declarations are 
hoisted to the top of their containing scope and 
initialized with "undefined". However, "let" and "const" 
declarations are also hoisted but not initialized.
"const foo = 1" declares a constant variable "foo" and
assigns it the value "1" in the outer scope. Inside the 
"bar" function, "console.log(foo)" attempts to log the 
value of "foo". However, there's a "const foo = 10"
declaration within the same function. In the hoisting 
phase, the "const foo = 10" is hoisted to the top of the 
"bar" function, but it is not initialized with "undefined". 
It remains uninitialized until the actual declaration 
statement is reached during execution.
The "console.log(foo)" line is encountered before the 
"const foo = 10" declaration is reached during 
execution. At this point, "foo" inside "console.log(foo)" 
refers to the outer "foo", which has a value of "1". 
However, since "const foo = 10" redeclares "foo" within 
the "bar" function, it triggers a Reference Error because
you cannot redeclare a "const" variable. If you change 
the "const" declaration inside the "bar" function to "let",
you would observe the result as "undefined". */
Answer: Reference Error

Task 5
function phoo() {
   return pfoo;
}
const phoObject = new phoo();
console.log(phoObject instanceof phoo);

/* when a function is invoked with the new keyword in
JavaScript, a new object is created. If there is an explicit
return statement in the function, the returned value is 
used as the result of the new operation.
In this code, the "phoo" function explicitly returns "pfoo",
but "pfoo" is not defined, resulting in a "Reference Error".
Due to the error, the "new phoo()" operation may not 
proceed as expected, and "phoObject" might not be an
instance of "phoo". 
To make the code work and properly check if "phoObject" 
is an instance of phoo, you should define "pfoo" or 
update the code accordingly. For example:
function phoo() {
   return this;
} -  here, the "phoo" function returns "this", which refers
to the newly created object, making "phoObject" an 
instance of "phoo".
instanceof also takes inheritance into account, it checks
the whole prototype chain to match the instance. To 
understand this let’s take this examples:
const fruits = ["Orange", "Kiwi", "Banana"]; 
console.log(fruits instanceof Array);  // true
console.log(fruits instanceof Object);  // true (Array is 
			    inherited from Object)
console.log(fruits instanceof Number); // false
console.log(fruits instanceof String); // false*/
Answer: false

Task 6
var y = 1;
if (function f() {}) {
   y += typeof f;
}
console.log(y);

/* In above code, "function f(){}" is treated as a function
expression because it's used within an expression 
context (as part of the if condition). Function expressions
do not get hoisted to the top of the scope like function 
declarations do. Instead, they are only defined and 
available for use after the point where they are defined 
in the code.
"if (function f(){}) { ... }" the anonymous function f(){} is 
treated as a function expression. It is not hoisted to the 
top of the scope, and it's only defined from this point 
onward. Therefore, it's not available before or after this
line. */
Answer: undefined

Task 7
What will be the order of logs in the console?
var z = 1, y = z = typeof y;
console.log(y);

/* According to the associativity rule, operators with 
the same precedence are processed based on the 
associativity property of the operator. Here, the asso-
ciativity of the assignment operator is Right to Left, so 
typeof "y" will evaluate first , which is "undefined". It
will be assigned to "z", and then "y" would be assigned
the value of "z" and then "z" would be assigned the 
value "1" */
Answer: undefined

Task 8
function foo1() {
  console.log("A");
  foo2();
  console.log("D");
}

async function foo2() {
  await foo3();
  console.log("C");
}

async function foo3() {
  console.log("B");
}

foo1();

/* whatever code we have written after "await" will run 
on the microtask queue. As soon as "foo3()" is executed,
next line "console.log("C")" will be pushed to microtask
queue, and once call stack is empty then it will get 
executed */

Task 9
Which option will execute console after 3000ms?
Option A: setTimeout(console.log("A"), 3000)
Option B: setTimeout.call(null, ()=> console.log("YES"), 3000);
Option C: setTimeout.call(null, console.log("YES"), 3000);

/* for option A - this doesn't delay the execution of 
"console.log("A")". It immediately invokes console.log("A"),
and the result of this function call ("undefined") is 
passed to "setTimeout". Therefore, this option does not 
achieve the intended delay;
for option B - in JS, when using "setTimeout", it's crucial
to pass a function reference as the first argument to 
delay its execution. In the case the arrow 
"function () => console.log("YES")" is passed as a 
function reference, ensuring that it will be invoked 
after the specified delay;
for Option C - the "console.log('YES')" is immediately 
executed, and the result ("undefined") is passed to 
"setTimeout". As a result, the "console.log('YES')" is not 
delayed. 
Actually we can say  except B in all other option we 
aren’t passing function, instead we are calling it */
Answer: B

Task 10
function fetchA() {
  A = 7;
  console.log(A);
}

let A;
fetchA();

/* variable named "A" is declared using the "let" keyword. 
This variable is declared in the global scope (or the 
scope of the block containing it). Variables declared
with "let" are not initialized with any value during
the hoisting process. They are in a "temporal dead zone"
until they are explicitly assigned a value.
Function call "fetchA()" triggers the execution of the 
function's code, inside the function, the line "A = 7" 
assigns the value "7" to the global variable "A". This 
variable "A" is the same one that was declared using 
let in the outer scope and console logs the value of "A" */
Answer: 7