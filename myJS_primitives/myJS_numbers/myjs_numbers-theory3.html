<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>myjs-primitives: числа</title>
    <style>
    body {
        background-color: tan;
        margin: 0;
        font-family: Verdana, sans-serif;
    }

    .title {
        color: red;
        text-align: center;
        font-weight:700;
    }

    .code-ex {
        width: 50%;
        font-family: sans-serif;
        background-color: #bebebe;
        font-size: large;
        padding-left: 15px;
        margin: 0 auto;
    }

    .task{
        width: 50%;
        padding: 15px 25px;
        color: navy;
        background-color: #e2e2e2;
        margin: 35px auto;
    }

    .code-ex {
        width: 50%;
        font-family: sans-serif;
        background-color: #bebebe;
        font-size: large;
        padding-left: 15px;
        margin: 0 auto;
    }

    p {
        width: 80%;
        margin: 0 auto;
    }

    table {
        border-collapse: collapse;
        width: 60%;
        margin: 0 auto;
    }

    th, td {
        text-align: center;
        padding: 8px;
        border: 1px solid brown;
    }

    tr:nth-child(even) {background-color: wheat;}

    tr:nth-child(odd) {background-color: #bebebe;}

    th {
        background-color: brown;
        color: wheat;
    }
    </style>
</head>
<body>

    <h2 class="title">myJS-primitives: числа: oкругление, неточные вычисления из-за внутреннего представления</h2>

    <h3>Округление</h3>

    <p>Одна из часто используемых операций при работе с числами – это округление.<br>
        В JavaScript есть несколько встроенных функций для работы с округлением:
    </p>
    <br>

    <h5>Math.floor</h5>

    <p>Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.</p>
    <br>

    <h5>Math.ceil</h5>

    <p>Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.</p>

    <h5>Math.round</h5>

    <p>Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.</p>

    <h5>Math.trunc</h5>

    <p>Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.<br>
        Но эта функция не поддерживается в Internet Explorer!
    </p>

    <h5>Различия между функциями округления</h5>

    <p>Ниже представлена таблица с различиями между функциями округления:</p>
    <br>

    <table>
        <tr>
        <th>Число</th>
        <th>Math.floor</th>
        <th>Math.ceil</th>
        <th>Math.round</th>
        <th>Math.trunc</th>
        </tr>
        <tr>
        <td>3.1</td>
        <td>3</td>
        <td>4</td>
        <td>3</td>
        <td>3</td>
        </tr>
        <tr>
        <td>3.6</td>
        <td>3</td>
        <td>4</td>
        <td>4</td>
        <td>3</td>
        </tr>
        <tr>
        <td>-1.1</td>
        <td>-2</td>
        <td>-1</td>
        <td>-1</td>
        <td>-1</td>
        </tr>
        <tr>
        <td>-1.6</td>
        <td>-2</td>
        <td>-1</td>
        <td>-2</td>
        <td>-1</td>
        </tr>
    </table>
    <br>
    
    <h3>Округление до n-ого количества цифр</h3> 

    <p>Вышеперечисленные функции охватывают все возможные способы обработки десятичной части. Но что если нам надо 
        округлить число до n-ого количества цифр в дробной части?<br>
        Например, у нас есть 1.2345 и мы хотим округлить число до 2-х знаков после запятой, оставить только 1.23.<br>
        Есть два пути решения:
    </p>

    <h5>Умножить и разделить</h5>

    <p></p>

    <p class="code-ex" style="width: 75%;">
        <code>
            let num = 1.23456;<br>
            <br>
            console.log( <b>Math.floor(num * 100) / 100</b> ); // 1.23456 -> 123.456 -> 123 -> <b>1.23</b><br>
        </code>
    </p>
    <br>

    <script>
        let num = 1.23456;
        
        console.log( Math.floor(num * 100) / 100 ); // 1.23
    </script>

    <h5>Метод toFixed(n)</h5>

    <p>Метод toFixed(n) округляет число до n знаков после запятой но возвращает строковое представление результата.</p>
    <br>

    <p class="code-ex">
        <code>
            let num = 12.34;<br>
            console.log( <b>num.toFixed(1)</b> ); // '12.3'<br>
        </code>
    </p>
    <br>

    <script>
        let num1 = 12.34;
        console.log( num1.toFixed(1) ); // '12.3'
    </script>

    <p>Округляет значение до ближайшего числа, как в большую, так и в меньшую сторону, аналогично методу Math.round:</p>

    <p class="code-ex">
        <code>
            let num = 12.36;<br>
            console.log( <b>num.toFixed(1)</b> ); // '12.4'<br>
        </code>
    </p>
    <br>

    <script>
        let num2 = 12.36;
        console.log( num2.toFixed(1) ); // '12.4'
    </script>

    <p>Обратите внимание, что результатом toFixed является строка. Если десятичная часть короче, чем необходима, 
        будут добавлены нули в конец строки:
    </p>
    <br>

    <p class="code-ex">
        <code>
            let num = 35.23;<br>
            console.log( num.toFixed(<b>5</b>) ); // <b>'35.23000'</b>, добавлены нули, чтобы получить 5 знаков после запятой<br>
        </code>
    </p>
    <br>

    <script>
        let num3 = 35.23;
        console.log( num3.toFixed(5) ); // '35.23000'
    </script>

    <p>Мы можем преобразовать полученное значение в число, используя унарный оператор + или Number(), 
        пример с унарным оператором: +num.toFixed(5).
    </p>
    <br>

    <p class="code-ex" style="width: 75%;">
        <code>
            let num = 74.3626;<br>
            console.log( <b>+</b>num.toFixed(2) ); // '74.36' -> <b>74.36</b> - преобразовали в число<br>
            одинаково как и:<br>
            console.log( <b>Number(</b>num.toFixed(2) <b>)</b> ); // 74.36
        </code>
    </p>
    <br>

    <script>
        let num4 = 74.3626;
        console.log( +num4.toFixed(2) ); // 74.36
        console.log( Number(num4.toFixed(2) ) ); // 74.36
    </script>

    <h3>Неточные вычисления</h3>

    <p>Внутри JavaScript число представлено в виде 64-битного формата IEEE-754. Для хранения числа используется 64 бита: 
        52 из них используется для хранения цифр, 11 из них для хранения положения десятичной точки (если число целое, 
        то хранится 0), и один бит отведён на хранение знака.<br>
        Если число слишком большое, оно переполнит 64-битное хранилище, JavaScript вернёт бесконечность:
    </p>
    <br>

    <p class="code-ex">
        <code>
            console.log( 1e500 ); // Infinity<br>
        </code>
    </p>
    <br>

    <script>
        console.log( 1e500 ); // Infinity
    </script>

    <p>Наиболее часто встречающаяся ошибка при работе с числами в JavaScript – это потеря точности.<br>
        Посмотрите на это (неверное!) сравнение:
    </p>
    <br>

    <p class="code-ex">
        <code>
            console.log( 0.1 + 0.2 == 0.3 ); // false<br>
        </code>
    </p>
    <br>

    <p>Да-да, сумма 0.1 и 0.2 не равна 0.3. Странно! Что тогда, если не 0.3? Давайте посмотрим в консоле:</p>
    <br>

    <p class="code-ex">
        <code>
            console.log( 0.1 + 0.2 ); // 0.30000000000000004<br>
        </code>
    </p>
    <br>

    <script>
        console.log( 0.1 + 0.2 ); // 0.30000000000000004
    </script>

    <p>Число хранится в памяти в бинарной форме, как последовательность бит – единиц и нулей. Что такое 0.1? 
        Это единица делённая на десять — 1/10, одна десятая. В десятичной системе счисления такие числа легко 
        представимы, по сравнению с одной третьей: 1/3, которая становится бесконечной дробью 0.33333(3)<br>
        Деление на 10 гарантированно хорошо работает в десятичной системе, но деление на 3 – нет. По той же 
        причине и в двоичной системе счисления, деление на 2 обязательно сработает, а 1/10 становится бесконечной 
        дробью. В JavaScript нет возможности для хранения точных значений 0.1 или 0.2, используя двоичную систему, 
        точно также, как нет возможности хранить одну третью в десятичной системе счисления. Числовой формат IEEE-754 
        решает эту проблему путём округления до ближайшего возможного числа. Правила округления обычно не позволяют 
        нам увидеть эту «крошечную потерю точности», но она существует. Вот пример:
    </p>
    <br>

    <p class="code-ex" style="width: 55%;">
        <code>
            console.log( 0.1.toFixed(20) ); // 0.10000000000000000555<br>
        </code>
    </p>
    <br>

    <script>
        console.log( 0.1.toFixed(20) ); // 0.10000000000000000555
    </script>

    <p>И когда мы суммируем 2 числа, их «неточности» тоже суммируются.<br>
        Вот почему 0.1 + 0.2 – это не совсем 0.3.<br>
        Справедливости ради заметим, что ошибка в точности вычислений для чисел с плавающей точкой сохраняется в любом 
        другом языке, где используется формат IEEE 754, включая PHP, Java, C, Perl, Ruby.
    </p>
    <br>

    <p>Можно ли обойти проблему? Конечно, наиболее надёжный способ — это округлить результат используя метод toFixed(n):</p>
    <br>

    <p class="code-ex">
        <code>
            let sum = 0.1 + 0.2;<br>
            console.log( sum.toFixed(2) ); // 0.30<br>
        </code>
    </p>
    <br>

    <p>Но метод toFixed всегда возвращает строку. Это гарантирует, что результат будет с заданным количеством цифр 
        в десятичной части. И далее можно использовать унарный оператор +, чтобы преобразовать строку в число.
    </p>
    <br>

    <p class="code-ex">
        <code>
            let sum = 0.1 + 0.2;<br>
            console.log( +sum.toFixed(2) ); // 0.3<br>
        </code>
    </p>
    <br>

    <script>
        let sum = 0.1 + 0.2;
        console.log( +sum.toFixed(2) ); // 0.3
    </script>

    <p>Также можно временно умножить число на 100 (или на большее), чтобы привести его к целому, выполнить математические 
        действия, а после разделить обратно. Суммируя целые числа, мы уменьшаем погрешность, но она все равно появляется 
        при финальном делении:
    </p>
    <br>

    <p class="code-ex" style="width: 65%;">
        <code>
            console.log( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3<br>
            console.log( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001<br>
        </code>
    </p>
    <br>

    <script>
        console.log( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
        console.log( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
    </script>

    <p>Таким образом, метод умножения/деления уменьшает погрешность, но полностью её не решает.</p>
    <br>

    <p> Вот ещё пример числа, растущее само по себе, как следствия внутреннего представления чисел:</p>
    <br>

    <p class="code-ex" style="width: 60%;">
        <code>
            console.log( 9999999999999999 ); // покажет 10000000000000000<br>
        </code>
    </p>
    <br>

    <script>
        console.log( 9999999999999999 ); // 10000000000000000
    </script>

    <p>Причина та же – потеря точности. Из 64 бит, отведённых на число, сами цифры числа занимают до 52 бит, 
        остальные 11 бит хранят позицию десятичной точки и один бит – знак. Так что если 52 бит не хватает на цифры, 
        то при записи пропадут младшие разряды.<br>
        Интерпретатор не выдаст ошибку, но в результате получится «не совсем то число», что мы и видим в примере выше. 
        Как говорится: «как смог, так записал».
    </p>
    <br>

    <p>Другим забавным следствием внутреннего представления чисел является наличие двух нулей: 0 и -0.<br>
        Все потому, что знак представлен отдельным битом, так что, любое число может быть положительным и отрицательным, 
        включая нуль.<br>
        В большинстве случаев это поведение незаметно, так как операторы в JavaScript воспринимают их одинаковыми.
    </p>


</body>

</html>