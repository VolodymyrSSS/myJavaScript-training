<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>myjs-primitives: методы у примитивов</title>
    <style>
    body {
        background-color: tan;
        margin: 0;
        font-family: Verdana, sans-serif;
    }

    .title {
        color: red;
        text-align: center;
        font-weight:700;
    }

    .code-ex {
        width: 50%;
        font-family: sans-serif;
        background-color: #bebebe;
        font-size: large;
        padding-left: 15px;
        margin: 0 auto;
    }

    .task{
        width: 50%;
        padding: 15px 25px;
        color: navy;
        background-color: #e2e2e2;
        margin: 35px auto;
    }

    .code-ex {
        width: 50%;
        font-family: sans-serif;
        background-color: #bebebe;
        font-size: large;
        padding-left: 15px;
        margin: 0 auto;
    }

    p {
        width: 80%;
        margin: 0 auto;
    }
    </style>
</head>
<body>

    <h2 class="title">myJS-primitives: методы у примитивов</h2>

    <h3>Различия между примитивами и объектами.</h3>

    <p>JavaScript позволяет нам работать с примитивными типами данных – строками, числами и т.д., как будто они 
        являются объектами. У них есть и методы. Но примитивы – не объекты. Давайте взглянем на ключевые различия 
        между примитивами и объектами.<br>
        <br>
        Примитив:<br>
        Это – значение «примитивного» типа.<br>
        Есть 6 примитивных типов: string, number, boolean, symbol, null и undefined.<br>
        <br>
        Объект:<br>
        Может хранить множество значений как свойства.<br>
        Объявляется при помощи фигурных скобок {}, например: {name: 'John', age: 40}. В JavaScript есть и другие 
        виды объектов: например, функции тоже являются объектами.<br>
        Существует множество встроенных объектов. Например, те, которые работают с датами, ошибками, HTML-элементами 
        и т.д. Они имеют различные свойства и методы.<br>
        Но объекты «тяжелее» примитивов. Они нуждаются в дополнительных ресурсах для поддержания внутренней структуры.<br>
    </p>
    <br>

    <p class="code-ex" style="width: 60%;">Одна из лучших особенностей объектов – это то, что мы можем хранить функцию как одно из свойств объекта.<br>
        <code>
            let maryna = {<br>
                name: 'Марина',<br>
                sayHi: function() {<br>
                  alert('Привет, красавица!'); }<br>
              };<br>
              <br>
              maryna.sayHi(); // Привет, красавица!<br>
        </code>
    </p>
    <br>

    <h3>Примитив как объект</h3>

    <p>Но, примитивы должны быть лёгкими и быстрыми. И было бы замечательно, если бы мы могли работать с ними 
        через вызовы методов.
    </p>
    <br>

    <p>Выбранное решение, хотя выглядит оно немного неуклюже:<br>
        1. Примитивы остаются примитивами. Одно значение, как и хотелось.<br>
        2. Язык позволяет осуществлять доступ к методам и свойствам строк, чисел, булевых значений и символов.<br>
        3. Чтобы это работало, при таком доступе создаётся специальный «объект-обёртка», который предоставляет 
        нужный функционал, а после удаляется.
    </p>
    <br>

    <p>Каждый примитив имеет свой собственный «объект-обёртку», которые называются: String, Number, Boolean и Symbol. 
        Таким образом, они имеют разный набор методов.
    </p>
    <br>

    <p>К примеру, существует <b>метод str.toUpperCase()</b>, который возвращает строку в верхнем регистре.
        Вот, как он работает:
    </p>
    <br>

    <p class="code-ex" style="width: 60%;">
        <code>
            let str = 'Howdy!';<br>
            <br>
            alert( str.toUpperCase() ); // HOWDY!<br>
        </code>
    </p>
    <br>

    <p>Движок JavaScript сильно оптимизирует этот процесс. Он даже может пропустить создание специального объекта. 
        Однако, он всё же должен придерживаться спецификаций и работать так, как будто он его создаёт.
    </p>
    <br>

    <p>Число имеет собственный набор методов. Например, <b>метод toFixed(n)</b> округляет число до n знаков после запятой.
        Вот, как он работает:
    </p>
    <br>

    <p class="code-ex" style="width: 60%;">
        <code>
            let n = 1.23456;<br>
            <br>
            alert( n.toFixed(2) ); // 1.23<br>
        </code>
    </p>
    <br>

    <p>Конструкторы String/Number/Boolean предназначены только для внутреннего пользования.</p>
    <br>

    <p>Особенные примитивы null и undefined являются исключениями. У них нет соответствующих «объектов-обёрток», и они 
        не имеют никаких методов. В некотором смысле, они «самые примитивные».
    </p>

    <h4 class="task">Взгляните на код ниже. Это сработает? Что выведется в консоль?</h4>

    <p class="code-ex">
        <code>
            let str = 'Привет';<br>
            <br>
            str.test = 5;<br>
            <br>
            console.log(str.test);<br>
        </code>
    </p>
    <br>

    <p><b>Ответ</b>: Примитивы не являются объектами. Они не могут хранить дополнительные данные.
        В зависимости от того, используете ли вы строгий режим (use strict) или нет, результат может быть:<br>
        1. undefined (без strict) или 2. TypeError: Cannot create property 'test' on string 'Привет' (strict mode).<br>
        <br>
        Давайте посмотрим что происходит в строке кода: str.test = 5;<br>
        -В момент обращения к свойству str создаётся «объект-обёртка».<br>
        -В строгом режиме, попытка изменения этого объекта выдаёт ошибку.<br>
        -Без строгого режима, операция продолжается, объект получает свойство test, но после этого он удаляется, 
        так что на последней линии str больше не имеет свойства test.<br>
    </p>

    <script>
        let str = "Привет";

        str.test = 5;

        console.log(str.test); // undefined
    </script>

<h4 class="task">Взгляните на код ниже.<br>
    1. Какой тип данных получим в консоле используя конструктор числа '0'?<br>
    2. Выведется ли в консоле выражение 'Я работаю'?
</h4>

<p class="code-ex">
    <code>
        console.log( typeof 0 ); // 0 -это 'число'<br>
        <br>
        console.log( typeof new Number(0) ); // ? -что будет?<br>
        <br>
        let zero = new Number(0);<br>
        if (zero) {<br>
          console.log( 'Я работаю' );<br>
        }<br>
    </code>
</p>
<br>

<p><b>Ответ</b>: Конструкторы String/Number/Boolean предназначены только для внутреннего пользования.<br>
    <br>
    Некоторые языки, такие как Java, позволяют явное создание «объектов-обёрток» для примитивов 
    при помощи такого синтаксиса как new Number(1) или new Boolean(false). В JavaScript, это тоже возможно 
    по историческим причинам, но <b>очень не рекомендуется</b>. 
    Поэтому в консоле получим такой тип данных как <b>'object'</b>.<br>
    <br>
    Но в некоторых местах последствия могут быть катастрофическими - как во второй части кода:
    Объекты в if всегда дают true, так что в нижеприведённом примере в консоль <b>будет выведено выражение 'Я работаю'</b><br>
    хотя в логике НЕ ДОЛЖНО РАБОТАТЬ и должны получить false, но zero возвращает 'true', так как является объектом.
</p>

    <script>
        console.log( typeof 0 ); // 0
        
        console.log( typeof new Number(0) ); // object
        
        let zero = new Number(0);
        if (zero) {
          console.log( 'Я работаю' );
        }
    </script>


</body>

</html>