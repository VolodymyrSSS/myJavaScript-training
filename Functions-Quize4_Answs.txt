Task 1
console.log(42.toString());

/* due to language grammar limitation, the "dot(.)" 
character could mean different things in JS. It can be 
seen as the member operator, or a decimal, depending 
on its placement.
In order to make above code work we have to either 
use parenthesis or an additional dot to make the 
expression valid, like:
21..toString(); // "21" or (21).toString(); // "21" */
Answer: Syntax Error: identifier starts immediately after numeric literal

Task 2
function toTheMoon() {
  console.log(arguments.constructor === {}.constructor);
  console.log(arguments.constructor === [].constructor);
}
 toTheMoon();

/* the line "arguments.constructor === {}.constructor" 
checks if the constructor property of the arguments 
object is equal to the constructor of an object ({}). The 
result of this comparison will be "true" if arguments is an
object;
the line "arguments.constructor === [].constructor"
checks if the constructor property of the arguments 
object is equal to the constructor of an array ([]). The 
result of this comparison will be "true" if arguments is 
an array;
So,  the arguments object in JavaScript is an object, the 
first console.log statement will print true. But the 
arguments object is not an array, so the second console
statement will print "false" */
Answer: true
Answer: false

Task 3
function toTheJupiter() {
   var a = [];
   a[Array.prototype.pop.apply(arguments)] = 1;
   return a;
}
console.log(toTheJupiter(0).length);
console.log(toTheJupiter(100).length);
console.log(toTheJupiter(Infinity).length);
console.log(toTheJupiter(NaN).length);

/* Points to consider:
point 1: "pop" array method removes element from last index, and 
returns the removed element.
point 2: we can increase the length of an array by 
simple assigning values to index. Examples:
const arr = []; // arr.length = 0
arr[4] = 1; // arr.length = 5
arr[400] = 1; // arr.length = 401
point 3: we can set values agains string keys other than
numerical indices; examples:
const arr = [];
arr["JS"] = 1 // no effect on length arr.length = 0
but arr["JS"] // arr.length = 1
point 4: "apply" method is used to call a function whose
context is defined by the first argument passed, and it 
accepts a second argument an array of parameters 
which is optional. Example:
const obj = {
  lang: 'JS'
}
function show() {
   console.log(this.lang);
}
show(); // logs "undefined"
show.apply(obj);  // logs "JS"
point 5: "arguments" - special array like object exist in 
every function, that is declared using function keyword.
This arguments object behaves similarly to an array in 
that it has numerical indices and a length property, but
it is not a proper array (it's array-like).
However, by using the "apply" or "call" method, you can
borrow methods from the "Array.prototype" and use
them on the arguments object or any other object.
We can convert arguments into array, to have all methods
by this way:
const argsArray = Array.prototype.slice.call(arguments);

for line "toTheJupiter(0)" - it applies pop on arguments,
which removes the last element "0" from arguments and
assigns it to "a[0] = 1". So, the array "a" becomes "[1]", 
and "console.log(toTheJupiter(0).length)" prints "1";
for line "toTheJupiter(100)" - similar to the first case, it 
applies pop on arguments (removing 100) and assigns 
it to "a[100] = 1". The array "a" becomes an array with a
length of 101 "([<empty>, <empty>, ..., <empty>, 1])", 
and console.log(toTheJupiter(100).length) prints "101".
for line "console.log(toTheJupiter(Infinity).length)" - the
array "a" got "arguments = Infinity" and after "pop", 
Infinity will return "index = Infinity" and array "a" looks 
like "a[Infinity] = 1" and the length is "0".
for line "console.log(toTheJupiter(NaN).length)" - similarly, 
the array "a" becomes "a[NaN] = 1", and the length 
is "0" */
Answer: 1
Answer: 101
Answer: 0
Answer: 0

Task 4
var a = 1;

function toTheMoon() {
   if (!a){
      var a = 10;
    }
    console.log(a);
}

toTheMoon();
console.log(a);

/* "var a = 1" - this variable has a global scope because
it is declared outside any function;
line "if (!a) { var a = 10; }" checks if "a" is falsy. If true, it 
declares a new variable "a" with the value "10" within 
the function's scope. However, due to hoisting, the 
variable declaration is moved to the top of the function,
so it does not affect the outer "a" variable;
"console.log(a)" prints the value of the local variable "a"
within the function's scope. Since there is a local 
variable "a", it logs 10. But outer "console.log(a)" prints 
the value of the global variable "a". This logs "1" because
the local variable inside the function does not affect the
global variable. Let's re-factor the code for the function:
 function toTheMoon() {
     var a; // var has function scope, hence it's declaration 
                will be hoisted
      if(!a) {
          a = 10;
       }
        console.log(a); // 10  precedence will be given to 
	               local scoped variable.
 } */
Answer: 10
Answer: 1

Task 5
How long will this data will be available?
sessionStorage.setItem("JS", 99991);

Answer: "sessionStorage.setItem("JS", 99991)" will be 
available for as long as the current browser session is 
active. Once the session ends (e.g., the user closes the 
tab or browser), the data will be cleared. As a matter 
of fact it will survive the refresh.

Task 6
const User = function() {};
User.prototype.attributes = {
   isAdmin: false
};
const admin = new User("X");
const guest = new User("Y");
admin.attributes.isAdmin = true;

console.log(admin.attributes.isAdmin);
console.log(guest.attributes.isAdmin);

/* both "admin" and "guest" object shares same 
prototype chain defined by "User.prototype.attributes"
When we are calling "admin.attributes.isAdmin" , JS 
engine will try to find the attributes key is "admin" 
object, when it doesn’t get any key with this name, it 
will look for the key in prototype chain. And guess what,
we have a key named "attributes" in prototype chain of
"admin" object. And hence JS engine will update the 
attributes key in prototype Object of "User" . Due to this
reason, when "guest" object will try to access this 
property it will also get "true".
To fix this, we should use attribute key separatley for 
each object. we should only use prototypes to share 
common functionality like this:
const User = function() {
  this.attributes = {
    isAdmin: false
  };
};
const admin = new User();
const guest = new User();
admin.attributes.isAdmin = true;
console.log(admin.attributes.isAdmin);  // true
console.log(guest.attributes.isAdmin);  // false
And if we to the prototype way, we have to use 
"defineProperty" and use "getter" and "setter" to enforce 
the restriction, like here"
function User() {}
Object.defineProperty(User.prototype, "isAdmin", {
  get: function() {
    return this._attributes.isAdmin;
  },
  set: function(value) {
    console.error("Cannot directly modify isAdmin property on prototype.");
  }
});

User.prototype._attributes = {
  isAdmin: false
};
const admin = new User();
const guest = new User();
admin.isAdmin = true;  // This will trigger the error message and not actually modify the property
console.log(admin.isAdmin);  // false
console.log(guest.isAdmin);  // false */
Answer: true
Answer: true

Task 7
(function() {
  var foo = 3;
  console.log(foo);
})();
console.log(foo);

/* the purpose of a self-executing function or IIFE - it’s 
all about variable scoping. By default, variables declared
in the self-executing function are only available to code
within the self-executing function. This allows code to be
written without concern of how variables are named in 
other blocks of JavaScript code */
Answer: 3
Answer: error - 'foo' is not defined

Task 8
(function() {
    var a = 1;
    (new Function('a = 2'))();
    console.log('a1 is ', a) ;
})();
console.log('a2 is ', a);

/* 
An immediately-invoked function expression (IIFE) is
used to create a new function scope. Inside this IIFE,
a variable "a" is declared and initialized to 1.
A new function is then created using the Function 
constructor (new Function('a = 2')()). Functions created
using the Function constructor do not inherit the scope 
from where they are created. Instead, they are always 
created in the global scope. The line a = 2 attempts to
assign the value 2 to a variable "a" in the global scope.
If "a" does not exist globally (which it doesn't here),
it will be implicitly created in non-strict mode or throw
a reference error in strict mode. 
The console.log('a1 is ', a); within the IIFE will print
the local variable "a" which remains "1" since the previous
function did not change the local "a" but rather tried to 
modify or create a global variable "a".
in JS, you can create a function using the Function 
constructor. The Function constructor takes a variable 
number of string arguments, where each string represents
a parameter name, followed by the function body as the
last argument. Here's the general syntax:
const funcName = new Function(arg1, arg2, ..., funcBody);
Here’s an example of how you can use the Function 
constructor to create a simple function:
const add = new Function('a', 'b', 'return a + b;');
console.log(add(2, 3));  // Output: 5
In a line, (new Function('a=2'))(): since "a" was declared
inside the IIFE, it is not accessible outside of that 
function (IIFE creates a local scope for a).
Because new Function('a = 2')() executes in the global scope
and in non-strict mode, it attempts to create and set a global
variable "a". As a result, running this code outside the IIFE
where we try to log a globally, you would either see a2 is 2 
if a was successfully created globally, or it could also raise 
a reference error if the environment is strict about implicit 
global variable creation. */
Answer: a1 is 1
Answer: a2 is 2

Task 9
function f1(a, b) {
   console.log(a, b);
}
let f2 = f1.bind(null, "boo");
f2("bar", "bac");

/* The given JavaScript code defines a function f1 that accepts
two parameters, a and b, and logs them to the console. Then, it
creates a new function f2 using the bind method on f1, with the
first argument a pre-set to "boo" and "this" value set to null.
When f2 is called with the arguments "bar" and "bac", it will call
the original function f1 with a preset to "boo" and b set to the
first argument provided to f2, which is "bar". The "bac" argument
passed to f2 is essentially ignored because f1 only logs the first
two arguments it receives. */
Answer: "boo", "bar"

Task 10
function createCounter() {
  let count = 0;

return function() {
    count++;
    console.log(`Current count: ${count}`);
  };
}
const counter1 = createCounter();
counter1(); // Current count: 1
counter1(); // Current count: 2
const counter2 = createCounter();
counter2(); // ?

/* Here we have classic closure. A closure is when a function remembers 
the variables from its outer scope, even after the outer function has 
finished executing. Closures allow for data privacy and help us write 
cleaner, modular code — especially when creating libraries, event listeners, 
or asynchronous logic.
So, even though createCounter() has finished running, the returned 
function still has access to the count variable — thanks to closures. This 
is like giving a function a backpack filled with its parent’s variables. It 
can access them anytime, anywhere. As well, counter2 call it's a separate 
closure.*/
Answer: 1


