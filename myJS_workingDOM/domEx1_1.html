<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Working with DOM</title>
    <style>
      body {
        background-color: tan;
        margin: 0;
        font-family: Verdana, sans-serif;
      }

      div {
        width: 60%;
        background-color: #bebebe;
        margin: auto;
      }

      h3 {
        color: #d87093;
        text-align: center;
      }

      .emph {
        color: red;
      }

      .title {
        color: navy;
        text-align: center;
        font-weight: 700;
      }

      .task {
        width: 50%;
        padding: 15px 25px;
        color: navy;
        background-color: #e2e2e2;
        margin: 35px auto;
      }

      p {
        width: 80%;
        margin: 0 auto;
      }

      pre {
        width: 50%;
        background-color: #bebebe;
        padding-top: 20px;
        margin: 0 auto;
      }

      code {
        font-family: Arial, Helvetica, sans-serif;
        font-size: large;
      }

      .code-ex {
        width: 50%;
        font-family: sans-serif;
        font-style: italic;
        background-color: #bebebe;
        font-size: large;
        padding-left: 15px;
        margin: 0 auto;
      }
    </style>
  </head>

  <body>
    <h2 class="title">DOM (data object model)</h2>
    <h4 class="title">
      Working with DOM: using <span class="emph">classList</span>, methods
      <span class="emph">createElements(), add(), appendChild()</span>,
      properties
      <span class="emph">elem.textContent, elem.innerHTML</span>,<br />
      searching method <span class="emph">querySelector()</span> and universal
      method <span class="emph">elem.insertAdjacentElement(where, elem)</span
      ><br />
    </h4>

    <h4 class="task">
      За допомогою існуючих методів та способів для роботи з DOM-елементами:<br />
      1. Створіть div-eлемент<br />
      2. Надайте цьому div-eлементу клас wrapper<br />
      3. Помістіть його всередину тегу <i>body</i><br />
      4. Створити заголовок h3 з назвою "DOM - Data Object Model"<br />
      5. Помістити h3 попереду div<br />
      6. Створити список ul та додати до нього 3 елементи li із текстом "один"
      "два" "три"<br />
      7. Помістити цей список ul всередину елементу div з класом wrapper<br />
    </h4>
    <br />

    <p><b>Результат:</b></p>
    <br />

    <script>
      const div = document.createElement('div');
      div.classList.add('wrapper');

      const body = document.querySelector('body');
      body.appendChild(div);

      const header = document.createElement('h3');
      header.textContent = 'DOM - Data Object Model';
      div.insertAdjacentElement('beforebegin', header);

      const ul = `
        <ul>
          <li>один</li>
          <li>два</li>
          <li>три</li>
        </ul>
      `;
      div.innerHTML = ul;
    </script>
    <br /><br />

    <p><b>Рішення:</b></p>
    <br />

    <p>
      Будь-який html-код в браузері формує
      <strong>Об'єктну Mодель Документу</strong> - <strong>DOM</strong>, яка
      представляє вміст усієї сторінки у виді об'єктів, які можна змінювати.
      Наглядно на це можна подивитись коли відкриєш вкладку інструментів
      розробника <i>Elements</i>, і можна бачити усю структуру DOM-дерева.
      Браузер дає змогу взаємодіяти з DOM-елементами за допомогою
      <strong>Java Script</strong>.<br />
      Далі необхідно зазначити, що в браузері існує глобальний об'єкт
      <strong>window</strong>, який має багато властивостей. Серед них,
      наприклад, <strong>location</strong> де знаходяться дані про поточну
      відкриту сторінку: URL-адрес, протокол, IP-адрес та інші; чи властивість
      <strong>innerWidth</strong>, що покаже ширину вікна браузера в пікселях,
      властивість <strong>navigator</strong>, яка містить більшістю інформацію
      про пристрій на якому працює і відкритий браузер.<br />
      Але є ще одна дуже важлива властивість - це <strong>document</strong>, що
      дає можливість працювати з DOM-елементами. Тобто, об'єкт <i>document</i> –
      основна "вхідна точка". З його допомогою ми можемо щось створювати чи
      змінювати на сторінці. Візуально, зона дії цієї властивості від
      відкриваючого до закриваючого тега <i>html</i>.
    </p>
    <br />

    <p>
      Таким чином, для роботи з DOM-елементами нам потрібно використовувати
      методи які починаються з об'єкта <strong><em>document</em></strong> і далі
      береться сам метод через крапку.<br />
      Почнемо виконання першого завдання і для цього створимо змінну, якій
      присвоємо DOM-елемент, щоб далі можна було працювати із цією змінною в
      JavaScript.<br />
      Узагалі, DOM-елемент створюють через метод
      <strong><em>createElement(tag)</em></strong
      >, де <i>tag</i> - це тег DOM-дерева, адже DOM – це подання HTML-документу
      у вигляді дерева тегів. <br />
      А методом <strong><em>createTextNode(text)</em></strong
      >, можемо створити DOM-елемент із заданим тектстом, бо текст, є також
      об'єктом.<br />
      У більшості необхідність по створенню DOM-елементів припадає на створення
      елементів типу <i>div</i>, то застосуємо перший спосіб, ось так:
    </p>
    <br />

    <p class="code-ex">
      <code>
        <pre>
          const div = document.createElement('div');
        </pre>
      </code>
    </p>
    <br />

    <p>
      Зауважимо, що DOM-елемент створено, але поки що він лише у змінній. Ми не
      можемо бачити його на сторінці, оскільки вона не є частиною документа.
    </p>
    <br />

    <p>
      Для присвоєння створеному div-елементу будь-якого класу використаємо вираз
      для класів - <strong><em>classList</em></strong
      >, а для безпосереднього його надання - метод
      <strong><em>add()</em></strong
      >, ось так:
    </p>
    <br />

    <p class="code-ex">
      <code>
        <pre>
          div.classList.add('wrapper');
        </pre>
      </code>
    </p>
    <br />

    <p>
      Щоб наш div з'явився, нам потрібно вставити його десь у document.
      Наприклад, у document.body. Щоб помістити елемент всередину body треба
      спочатку знайти його та звернутись до нього. Для цього існує метод
      <strong><em>querySelector()</em></strong
      >. Тут body має особливості - до нього можна звертатись напряму бо це є
      тіло самого глобального <em>document</em>, робимо це ось так:
    </p>
    <br />

    <p class="code-ex">
      <code>
        <pre>
          const body = document.querySelector('body');
          або так
          const body = document.body;
        </pre>
      </code>
    </p>
    <br />

    <p>
      І щоб помістити всередину body, існує метод append:
      <strong><em>document.body.append(div)</em></strong
      >.<br />
      Але також існує старий метод додавання елемента на сторінку -
      <strong><em>appendChild()</em></strong
      >, ось так:
    </p>
    <br />

    <p class="code-ex">
      <code>
        <pre>
          body.appendChild(div);
        </pre>
      </code>
    </p>
    <br />

    <p>
      Робимо h3 по аналогії створення div-елемента використавши для цього метод
      <strong><em>createElement()</em></strong
      >, та властивість для текстових значень
      <strong><em>textContent</em></strong
      >. Властивість textContent надає доступ до тексту всередині елемента за
      винятком всіх тегів. У разі запису до нього тексту разом із
      HTML-симворалми, ці спеціальні символи і теги інтерпретуються як текст і
      не добавляться як частина HTML-коду. Тобто, ця властивість дозволяє писати
      текст безпечним способом бо ми не хочемо, щоб на сайті з'являвся якийсь
      довільний HTML-код.<br />
      Отже, спочатку створюємо заголовок, а потім туди передаємо текстовий
      контент, ось так:
    </p>
    <br />

    <p class="code-ex">
      <code>
        <pre>
          const header = document.createElement('h3');
          header.textContent = 'DOM - data Object Model';
        </pre>
      </code>
    </p>
    <br />

    <p>
      Якщо ми хочемо вставити HTML саме «як html», з усіма тегами та іншим
      синтаксисом, подібно до того, як це робить <em>elem.innerHTML()</em> то
      необхідно використати доволі потужний та універсальний метод:<br />
      <strong><em>elem.insertAdjacentHTML(where, html)</em></strong
      ><br />
      Перший параметр - це спеціальне слово, що вказує, куди по відношенню до
      elem робити вставку. Значення має бути одним із наступних:<br />
      - "beforebegin" – вставити html безпосередньо перед elem,<br />
      - "afterbegin" – вставити html на початок elem,<br />
      - "beforeend" – вставити html в кінець elem,<br />
      - "afterend" – вставити html безпосередньо після elem.<br />
      Другий параметр – це HTML-рядок-символів. який буде вставлений у визначене
      місце «як html».<br /><br />
      У цього метода є два брати:<br />
      <strong><em>elem.insertAdjacentText(where, text)</em></strong>
      – такий самий синтаксис, але рядок символів text вставляється «як текст»,
      замість HTML,<br />
      <strong><em>elem.insertAdjacentElement(where, elem)</em></strong>
      – такий самий синтаксис, але вставляє елемент elem.<br />
      В нашому випадку вже є створений елемент header, який ми вставляємо перед
      блоком div згідно із завданням, тому можемо використати метод
      <em>elem.insertAdjacentElement(where, elem)</em> ось так: <br />
    </p>
    <br />

    <p class="code-ex">
      <code>
        <pre>
          div.insertAdjacentElement('beforebegin', header);
        </pre>
      </code>
    </p>
    <br />

    <p>
      Ці три методи існують, переважно, щоб уніфікувати синтаксис. На практиці
      часто використовується тільки <em>insertAdjacentHTML</em>. Тому що для
      елементів та тексту ми маємо методи append/prepend/before/after – їх
      швидше написати, і вони можуть вставляти як вузли, так і текст.
    </p>
    <br />

    <p>
      Зауважимо, що другий параметр універсального методу
      <strong><em>elem.insertAdjacentHTML(where, html)</em></strong
      >– це може бути HTML-рядок-символів, який буде вставлений саме «як HTML»(з
      усіма тегами та іншим синтаксисом). Тому можна використати в цьому
      елементі HTML-рядок-символів.<br />
      Давайте створемо такий елемент «як HTML» і використаєм для цього зворотні
      лапки, щоб писати розмітку на різних рядках та одразу задати цілий блок
      коду, ось так:
    </p>
    <br />

    <p class="code-ex">
      <code>
        <pre>
          const ul = `
            &lt;ul&gt;
              &lt;li&gt;один&lt;/li&gt;
              &lt;li&gt;два&lt;/li&gt;
              &lt;li&gt;три&lt;/li&gt;
            &lt;/ul&gt;
          `
        </pre>
      </code>
    </p>
    <br />

    <p>
      Щоб помістити створений список в div тепер використаємо властивість
      <strong><em>elem.innerHTML</em></strong
      ><br />
      Ця властивість дозволяє отримати HTML-вміст елементу у вигляді рядка
      символів. Або можна сказати так: З в innerHTML вставка відбувається «як
      HTML», з усіма HTML-тегами. Властивість <em>innerHTML</em> є лише у
      вузлів-елементів. Отже, щоб помістити список ul всередину елементу div,
      достатньо тільки присвоїти цій властивості змінну в якій вже створений цей
      елемент «як HTML» і цей елемент вставиться на веб-сторінку «як HTML», ось
      так:
    </p>
    <br />

    <p class="code-ex">
      <code>
        <pre>
          div.innerHTML = ul;
        </pre>
      </code>
    </p>
    <br /><br /><br />
  </body>
</html>
