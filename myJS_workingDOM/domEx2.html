<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Working with DOM</title>
    <style>
      body {
        background-color: tan;
        margin: 0;
        font-family: Verdana, sans-serif;
      }

      div {
        width: 60%;
        background-color: #bebebe;
        margin: auto;
      }

      .img-centered {
        display: block;
        margin-left: auto;
        margin-right: auto;
        border: 2px solid black;
        border-radius: 8px;
        padding: 3px;
      }

      h3 {
        color: #d87093;
        text-align: center;
      }

      .emph {
        color: red;
      }

      .title {
        color: navy;
        text-align: center;
        font-weight: 700;
      }

      .task {
        width: 50%;
        padding: 15px 25px;
        color: navy;
        background-color: #e2e2e2;
        margin: 35px auto;
      }

      p {
        width: 80%;
        margin: 0 auto;
      }

      pre {
        width: 50%;
        background-color: #bebebe;
        padding-top: 20px;
        margin: 0 auto;
      }

      code {
        font-family: Arial, Helvetica, sans-serif;
        font-size: large;
      }

      .code-ex {
        width: 50%;
        font-family: sans-serif;
        font-style: italic;
        background-color: #bebebe;
        font-size: large;
        padding-left: 15px;
        margin: 0 auto;
      }
    </style>
  </head>

  <body>
    <h2 class="title">DOM (data object model)</h2>
    <h4 class="title">
      Working with DOM: using <span class="emph">classList</span>, methods
      <span class="emph">createElements(), add(), appendChild()</span>,
      properties
      <span class="emph">elem.textContent, elem.innerHTML</span>,<br />
      searching method <span class="emph">querySelector()</span> and universal
      method <span class="emph">elem.insertAdjacentElement(where, elem)</span
      ><br />
    </h4>

    <h4 class="task">
      За допомогою методів та способів для роботи з DOM-елементами:<br />
      1. Створіть div-eлемент<br />
      2. Надайте цьому div-eлементу клас <i>wrapper</i> із сірим фоном та
      помістіть на сторінку<br />
      3. Потім створіть img-eлемент<br />
      4. Задайте йому атрибут <i>src</i><br />
      5. Також, задайте обов'язковий атрибут <i>alt</i> і одночасно і ширину
      240рх<br />
      6. Потім задайте йому клас <i>img-centered</i>, щоб було центрування
      картинки<br />
      7. Помістіть img-eлемент в div-eлемент<br />
    </h4>
    <br />

    <p><b>Результат:</b></p>
    <br />

    <script>
      const div = document.createElement('div');

      div.classList.add('wrapper');

      const body = document.body;
      // const body = document.querySelector('body');

      document.body.append(div);
      // body.appendChild(div);

      const img = document.createElement('img');
      img.src = 'https://picsum.photos/240';
      img.alt = 'random image';
      img.width = 240;
      img.classList.add('img-centered');

      div.appendChild(img);
    </script>
    <br /><br />

    <p><b>Рішення:</b></p>
    <br />

    <p>
      Для роботи з DOM-елементами нам потрібно використовувати методи які
      починаються з слова <strong><em>document</em></strong> і далі береться
      (через крапку - як в об'єкті) безпосередня назва самого методу.<br />
      Почнемо виконання завдань з першого і для цього створимо змінну, якій
      присвоємо створений DOM-елемент, використавши метод
      <strong><em>createElement(tag)</em></strong
      >, який створює новий DOM-елемент у заданому тегу; адже DOM – це подання
      HTML-документу у вигляді дерева тегів, ось так:
    </p>
    <br />

    <p class="code-ex">
      <code>
        <pre>
          const div = document.createElement('div');
        </pre>
      </code>
    </p>
    <br />

    <p>
      Зауважимо, що DOM-елемент створено, але поки що він лише у змінній. Ми не
      можемо бачити цей елемент (вузел) на сторінці, оскільки він не є частиною
      моделі HTML-документа.
    </p>
    <br />

    <p>
      Для задання створеному DOM-елементу будь-якого класу використаємо вираз -
      <strong><em>classList</em></strong
      >, a щоб його безпосередньо задати - метод <strong><em>add()</em></strong
      >, ось так:
    </p>
    <br />

    <p class="code-ex">
      <code>
        <pre>
          div.classList.add('wrapper');
        </pre>
      </code>
    </p>
    <br />

    <p>
      Щоб наш div з'явився, нам потрібно помістити його в середину <i>body</i>,
      а щоб зробити так треба спочатку його знайти в DOM, наприклад методом
      <strong><em>querySelector()</em></strong> a вже потім щось робити з ним.
      Але <i>body</i> має особливість - до нього можна звернутись напряму бо це
      є метод самого глобального об'єкта <em>document</em>, тому можемо зробити
      це двома способами:
    </p>
    <br />

    <p class="code-ex">
      <code>
        <pre>
          const body = document.querySelector('body');
          // або так
          const body = document.body;
        </pre>
      </code>
    </p>
    <br />

    <p>
      І щоб помістити всередину <i>body</i>, існує метод:
      <strong><em>append()</em></strong
      >.<br />
      Або методом <strong><em>appendChild()</em></strong> що своєю назвою сам
      показує, що робить - додавання дочірного елементу в батьківський, ось так:
    </p>
    <br />

    <p class="code-ex">
      <code>
        <pre>
          document.body.append(div);
          // або так
          body.appendChild(div)
        </pre>
      </code>
    </p>
    <br />

    <p>
      По аналогії, створюємо img-елемент методом
      <strong><em>createElement(tag)</em></strong
      >, де визначаємо тег як <i>img</i> ось так:
    </p>
    <br />

    <p class="code-ex">
      <code>
        <pre>
          const img = document.createElement('img');
        </pre>
      </code>
    </p>
    <br />

    <p>
      Додаємо атрибут <i>src</i> та одразу прописуємо його URL як
      'https://picsum.photos/240' з якого буде братись рандомно зображення і
      далі задамо необхідний атрибут <i>alt</i> і одразу й ширину 240рх, ось
      так:
    </p>
    <br />

    <p class="code-ex">
      <code>
        <pre>
          img.src = 'https://picsum.photos/240';
          img.alt = 'random image';
          img.width = 240;
        </pre>
      </code>
    </p>
    <br />

    <p>
      Для присвоєння створеному div-елементу будь-якого класу використаємо вираз
      для присвоєння класів - <strong><em>classList</em></strong
      >, а для безпосереднього його надання - метод
      <strong><em>add()</em></strong
      >, ось так:
    </p>
    <br />

    <p class="code-ex">
      <code>
        <pre>
          img.classList.add('img-centered');
        </pre>
      </code>
    </p>
    <br />

    <p>
      І щоб помістити дочірне зображення усередину батьківського div-елемента,
      використаємо метод
      <strong><em>appendChild()</em></strong
      >, ось так:
    </p>
    <br />

    <p class="code-ex">
      <code>
        <pre>
          div.appendChild(img);
        </pre>
      </code>
    </p>
    <br />

    <p>
      Робимо h3 по аналогії створення div-елемента використавши для цього метод
      <strong><em>createElement()</em></strong
      >, та властивість для текстових значень
      <strong><em>textContent</em></strong
      >. Властивість textContent надає доступ до тексту всередині елемента за
      винятком всіх тегів. У разі запису до нього тексту разом із
      HTML-симворалми, ці спеціальні символи і теги інтерпретуються як текст і
      не добавляться як частина HTML-коду. Тобто, ця властивість дозволяє писати
      текст безпечним способом бо ми не хочемо, щоб на сайті з'являвся якийсь
      довільний HTML-код.<br />
      Отже, спочатку створюємо заголовок, а потім туди передаємо текстовий
      контент, ось так:
    </p>
    <br />

    <p class="code-ex">
      <code>
        <pre>
          const header = document.createElement('h3');
          header.textContent = 'DOM - data Object Model';
        </pre>
      </code>
    </p>
    <br />

    <p>
      Якщо ми хочемо вставити HTML саме «як html», з усіма тегами та іншим
      синтаксисом, подібно до того, як це робить <em>elem.innerHTML()</em> то
      необхідно використати доволі потужний та універсальний метод:<br />
      <strong><em>elem.insertAdjacentHTML(where, html)</em></strong
      ><br />
      Перший параметр - це спеціальне слово, що вказує, куди по відношенню до
      elem робити вставку. Значення має бути одним із наступних:<br />
      - "beforebegin" – вставити html безпосередньо перед elem,<br />
      - "afterbegin" – вставити html на початок elem,<br />
      - "beforeend" – вставити html в кінець elem,<br />
      - "afterend" – вставити html безпосередньо після elem.<br />
      Другий параметр – це HTML-рядок-символів. який буде вставлений у визначене
      місце «як html».<br /><br />
      У цього метода є два брати:<br />
      <strong><em>elem.insertAdjacentText(where, text)</em></strong>
      – такий самий синтаксис, але рядок символів text вставляється «як текст»,
      замість HTML,<br />
      <strong><em>elem.insertAdjacentElement(where, elem)</em></strong>
      – такий самий синтаксис, але вставляє елемент elem.<br />
      В нашому випадку вже є створений елемент header, який ми вставляємо перед
      блоком div згідно із завданням, тому можемо використати метод
      <em>elem.insertAdjacentElement(where, elem)</em> ось так: <br />
    </p>
    <br />

    <p class="code-ex">
      <code>
        <pre>
          div.insertAdjacentElement('beforebegin', header);
        </pre>
      </code>
    </p>
    <br />

    <p>
      Ці три методи існують, переважно, щоб уніфікувати синтаксис. На практиці
      часто використовується тільки <em>insertAdjacentHTML</em>. Тому що для
      елементів та тексту ми маємо методи append/prepend/before/after – їх
      швидше написати, і вони можуть вставляти як вузли, так і текст.
    </p>
    <br />

    <p>
      Зауважимо, що другий параметр універсального методу
      <strong><em>elem.insertAdjacentHTML(where, html)</em></strong
      >– це може бути HTML-рядок-символів, який буде вставлений саме «як HTML»(з
      усіма тегами та іншим синтаксисом). Тому можна використати в цьому
      елементі HTML-рядок-символів.<br />
      Давайте створемо такий елемент «як HTML» і використаєм для цього зворотні
      лапки, щоб писати розмітку на різних рядках та одразу задати цілий блок
      коду, ось так:
    </p>
    <br />

    <p class="code-ex">
      <code>
        <pre>
          const ul = `
            &lt;ul&gt;
              &lt;li&gt;один&lt;/li&gt;
              &lt;li&gt;два&lt;/li&gt;
              &lt;li&gt;три&lt;/li&gt;
            &lt;/ul&gt;
          `
        </pre>
      </code>
    </p>
    <br />

    <p>
      Щоб помістити створений список в div тепер використаємо властивість
      <strong><em>elem.innerHTML</em></strong
      ><br />
      Ця властивість дозволяє отримати HTML-вміст елементу у вигляді рядка
      символів. Або можна сказати так: З в innerHTML вставка відбувається «як
      HTML», з усіма HTML-тегами. Властивість <em>innerHTML</em> є лише у
      вузлів-елементів. Отже, щоб помістити список ul всередину елементу div,
      достатньо тільки присвоїти цій властивості змінну в якій вже створений цей
      елемент «як HTML» і цей елемент вставиться на веб-сторінку «як HTML», ось
      так:
    </p>
    <br />

    <p class="code-ex">
      <code>
        <pre>
          div.innerHTML = ul;
        </pre>
      </code>
    </p>
    <br /><br /><br />
  </body>
</html>
